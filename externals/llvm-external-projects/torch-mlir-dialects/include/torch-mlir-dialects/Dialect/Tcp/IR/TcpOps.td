//===-------------------------------------------------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Also available under a BSD-style license. See LICENSE.
//
//===----------------------------------------------------------------------===//

#ifndef TORCH_MLIR_DIALECT_TCP_OPS
#define TORCH_MLIR_DIALECT_TCP_OPS

include "torch-mlir-dialects/Dialect/Tcp/IR/TcpBase.td"

include "mlir/IR/OpBase.td"

def Tcp_TanhOp : Tcp_UnaryElementwiseOp<"tanh"> {
  let summary = "Computes tanh of input, elementwise";

  let description = [{
    Computes elementwise hyperbolic tangent of the input tensor.
  }];

  let arguments = (ins
    Tcp_FloatOrComplexTensor:$in
  );

  let results = (outs
    Tcp_FloatOrComplexTensor:$out
  );

  let assemblyFormat = "$in attr-dict `:` type($in) `->` type($out)";
}

def Tcp_ClampOp : Tcp_UnaryElementwiseOp<"clamp"> {
  let summary = "Clamps input tensor to the given min and/or max";

  let description = [{
    Clamps the input tensor, elementwise, to the given min and/or max values.

    The min and max values specified as attributes should correspond to the
    element type of the input tensor.
     * If the input is a float tensor, only `min_float` and/or `max_float` must
       be specified.
     * If the input is an int tensor, only `min_int` and/or `max_int` must be
       specified.
  }];

  // TODO: Does clamp need to support complex tensors?
  let arguments = (ins
    Tcp_FloatOrIntTensor:$in,
    OptionalAttr<F32Attr>:$min_float,
    OptionalAttr<F32Attr>:$max_float,
    OptionalAttr<I64Attr>:$min_int,
    OptionalAttr<I64Attr>:$max_int
  );

  let results = (outs
    Tcp_FloatOrIntTensor:$out
  );

  let assemblyFormat = "$in attr-dict `:` type($in) `->` type($out)";

  let hasVerifier = 1;
}

def Tcp_SigmoidOp : Tcp_UnaryElementwiseOp<"sigmoid"> {
  let summary = "Computes sigmoid of input, elementwise";

  let description = [{
    Computes elementwise sigmoid of the input tensor.
  }];

  let arguments = (ins
    Tcp_FloatOrComplexTensor:$in
  );

  let results = (outs
    Tcp_FloatOrComplexTensor:$out
  );

  let assemblyFormat = "$in attr-dict `:` type($in) `->` type($out)";
}

def Tcp_AddOp : Tcp_BinaryElementwiseOp<"add", [SameOperandsAndResultElementType]> {
  let summary = "Computes elementwise addition";

  let description = [{
    Computes the elementwise addition of `in1` and `in2`.
  }];

  let arguments = (ins
    Tcp_Tensor:$in1,
    Tcp_Tensor:$in2
  );

  let results = (outs
    Tcp_Tensor:$out
  );

  let assemblyFormat = "$in1 `,` $in2 attr-dict `:` type($in1) `,` type($in2) `->` type($out)";
}

def Tcp_SubOp : Tcp_BinaryElementwiseOp<"sub", [SameOperandsAndResultElementType]> {
  let summary = "Computes elementwise subtraction";

  let description = [{
    Computes the elementwise subtraction of `in2` from `in1`.
  }];

  let arguments = (ins
    Tcp_Tensor:$in1,
    Tcp_Tensor:$in2
  );

  let results = (outs
    Tcp_Tensor:$out
  );

  let assemblyFormat = "$in1 `,` $in2 attr-dict `:` type($in1) `,` type($in2) `->` type($out)";
}

def Tcp_MulOp : Tcp_BinaryElementwiseOp<"mul", [SameOperandsAndResultElementType]> {
  let summary = "Computes elementwise multiplication";

  let description = [{
    Computes the elementwise multiplication of `in1` and `in2`.
  }];

  let arguments = (ins
    Tcp_Tensor:$in1,
    Tcp_Tensor:$in2
  );

  let results = (outs
    Tcp_Tensor:$out
  );

  let assemblyFormat = "$in1 `,` $in2 attr-dict `:` type($in1) `,` type($in2) `->` type($out)";
}

def Tcp_DivFOp : Tcp_BinaryElementwiseOp<"divf", [SameOperandsAndResultElementType]> {
  let summary = "Computes elementwise floating point division";

  let description = [{
    Computes the elementwise floating point division of `in1` and `in2`.
  }];

  let arguments = (ins
    Tcp_FloatTensor:$in1,
    Tcp_FloatTensor:$in2
  );

  let results = (outs
    Tcp_FloatTensor:$out
  );

  let assemblyFormat = "$in1 `,` $in2 attr-dict `:` type($in1) `,` type($in2) `->` type($out)";
}

def Tcp_ConstOp : Tcp_Op<"const", [ConstantLike, Pure]> {
  let summary = "Constant op";

  let description = [{
    An op that produces constant tensor (of floating point or signless integer type).
  }];

  let arguments = (ins
    ElementsAttr:$value
  );

  let results = (outs
    Tcp_Tensor:$out
  );

  let assemblyFormat = "attr-dict `:` type($out)";

  let hasFolder = 1;
}

def Tcp_BroadcastOp : Tcp_Op<"broadcast", [
          AllRanksMatch<["in", "out"]>,
          AllElementTypesMatch<["in", "out"]>]> {
  let summary = "Broadcasts input to a given shape";

  let description = [{
    Broadcasts `in` to a given shape by replicating dimensions with bound `1`.

    All of the dimensions listed in `axes` must have a static size of `1` in
    `in`.  The dimesion `axis[i]` will be replicated `new_dim_sizes[i]` times in
    the output.

    This op does not change the rank of the input.

    The attribute `$axes` must be sorted and not have any duplicates. The size
    of `$axes` must be equal to the size of the variadic argument `$new_dim_sizes`.
  }];

  let arguments = (ins
    Tcp_Tensor:$in,
    Variadic<Index>:$new_dim_sizes,
    I64ArrayAttr:$axes
  );

  let results = (outs
    Tcp_Tensor:$out
  );

  let assemblyFormat = "$in `,` $new_dim_sizes attr-dict `:` type($in) `,` type($new_dim_sizes) `->` type($out)";

  let hasVerifier = 1;
}

def Tcp_YieldOp : Tcp_Op<"yield", [Terminator, Pure]> {
  let summary = "Yields values from regions in Tcp";

  let description = [{
    Terminates and yields values from regions in Tcp.

    The values that are yielded should correspond to the parent operation's
    results.
  }];

  let arguments = (ins
    Variadic<Tcp_TensorOrScalar>:$ins
  );

  let builders = [
    OpBuilder<(ins), [{ }]>,
  ];

  let assemblyFormat = "$ins attr-dict `:` type($ins)";
}

def Tcp_GroupOp : Tcp_Op<"group", [
          AffineScope,
          ParentOneOf<["func::FuncOp", "tcp::GroupOp", "tcp::IsolatedGroupOp"]>,
          SingleBlockImplicitTerminator<"tcp::YieldOp">]> {
  let summary = "Groups ops into a region that is not isolated from above";

  let description = [{
    Provides a way to group ops into a region that is not isolated from above.

    Since this is not isolated from above, ops inside this region can refer to
    values in the outer scopes. So, this op does not have any input parameters.

    This op must not include control flow ops in its region. However, it can
    be present within regions that are inside control flow ops.

    The enclosed region will terminate with a `tcp.yield` op. This ops results
    should correspond to the values that are yielded by the terminating op.
  }];

  let results = (outs
    Variadic<Tcp_TensorOrScalar>:$outs
  );

  let regions = (region
    SizedRegion<1>:$body
  );

  let assemblyFormat = "attr-dict-with-keyword $body `:` type($outs)";

  let hasVerifier = 1;
}

def Tcp_IsolatedGroupOp : Tcp_Op<"isolated_group", [
          AffineScope,
          IsolatedFromAbove,
          ParentOneOf<["func::FuncOp", "tcp::GroupOp", "tcp::IsolatedGroupOp"]>,
          SingleBlockImplicitTerminator<"tcp::YieldOp">]> {
  let summary = "Groups ops into a region that is isolated from above";

  let description = [{
    Provides a way to group ops into a region that is isolated from above.

    Since the enclosed region is isolated from above, any use of values from
    outer scopes requires passing that value as an input parameter to this op
    and using that parameter instead.

    This op must not include control flow ops in its region. However, it can
    be present within regions that are inside control flow ops.

    The enclosed region will terminate with a `tcp.yield` op. This ops results
    should correspond to the values that are yielded by the terminating op.
  }];

  let arguments = (ins
    Variadic<Tcp_TensorOrScalar>:$ins
  );

  let results = (outs
    Variadic<Tcp_TensorOrScalar>:$outs
  );

  let regions = (region
    SizedRegion<1>:$body
  );

  let assemblyFormat = "$ins attr-dict-with-keyword $body `:` type($ins) `->` type($outs)";

  let hasVerifier = 1;
}

def Tcp_SqrtOp : Tcp_UnaryElementwiseOp<"sqrt", [SameOperandsAndResultElementType]> {
  let summary = "Computes square root of input, elementwise";

  let description = [{
    Computes elementwise square root of the input tensor.
  }];

  let arguments = (ins
    Tcp_FloatOrComplexTensor:$in
  );

  let results = (outs
    Tcp_FloatOrComplexTensor:$out
  );

  let assemblyFormat = "$in attr-dict `:` type($in) `->` type($out)";
}

#endif // TORCH_MLIR_DIALECT_TCP_OPS
