#pragma once

#include <ATen/core/interned_strings.h>
#include <torch/csrc/lazy/backend/lowering_context.h>
#include <torch/csrc/lazy/core/shape.h>
#include <torch/csrc/lazy/core/ir.h>

#include "mlir_lowering_context.h"
#include "../utils/exception.h"

namespace torch {
namespace lazy {

typedef std::vector<NodePtr> MlirOpVector;
typedef NodePtr MlirFunction;


class MlirNode : public torch::lazy::Node {

  public:
    MlirNode(
        OpKind op, OpList operands, std::vector<Shape>&& shapes,
        size_t num_outputs = 1, hash_t hash_seed = kHashSeed
    );

    // Same as the constructor above, but the shape is generated by a function,
    // only if needed (shape cache miss).
    MlirNode(
        OpKind op, OpList operands,
        const std::function<Shape()>& shape_fn,
        size_t num_outputs = 1, hash_t hash_seed = kHashSeed
    );

    // The shape is set later.
    MlirNode(
        OpKind op, OpList operands, size_t num_outputs = 1,
        hash_t hash_seed = kHashSeed
    );

    void SetShapeDeferred(const std::function<Shape()>& shape_fn);

    // Contructor used to create leaf nodes.
    MlirNode(
        OpKind op, Shape shape, size_t num_outputs = 1, hash_t hash_seed = kHashSeed
    );

    Shape GetOpShape(const std::function<Shape()>& shape_fn) const;

    const std::vector<Output>& operands() const override;

    const Output& operand(size_t i) const override;

    virtual MlirOpVector Lower(
        MlirFunction function,
        MlirLoweringContext* loctx
    ) const = 0;

 private:
    // Adds node's index output number as operand.
    void AddOperand(NodePtr node, size_t index = 0);

    std::vector<Shape> shapes_;
    // A node holds a real reference to its operands.
    std::vector<NodePtr> operands_;
    // Outputs do not hold references on the nodes, and neither do the uses, since
    // otherwise we get into circular reference counting.
    std::vector<Output> operands_as_outputs_;
};

}  // namespace lazy
}  // namespace torch
