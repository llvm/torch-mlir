//===- mlir_node.h --------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Also available under a BSD-style license. See LICENSE.
//
//===----------------------------------------------------------------------===//
// This file is adapted from pytorch/pytorch
// https://github.com/pytorch/pytorch/blob/lazy_tensor_staging/torch/csrc/lazy/ts_backend/ts_node.h
//===----------------------------------------------------------------------===//

#pragma once

#include <ATen/core/interned_strings.h>
#include <torch/csrc/lazy/backend/lowering_context.h>
#include <torch/csrc/lazy/core/ir.h>
#include <torch/csrc/lazy/core/shape.h>

#include "../utils/exception.h"
#include "aten_eager_fallback.h"
#include "mlir_lowering_context.h"

namespace torch {
namespace lazy {

typedef std::vector<NodePtr> MlirOpVector;
typedef NodePtr MlirFunction;

class TORCH_API MlirNode : public torch::lazy::Node {

public:
  MlirNode(
      OpKind op, OpList operands, std::vector<Shape>&& shapes,
      size_t num_outputs = 1, hash_t hash_seed = kHashSeed);

  // Same as the constructor above, but the shape is generated by a function,
  // only if needed (shape cache miss).
  MlirNode(
      OpKind op, OpList operands, const std::function<Shape()>& shape_fn,
      size_t num_outputs = 1, hash_t hash_seed = kHashSeed);

  // The shape is set later.
  MlirNode(
      OpKind op, OpList operands, size_t num_outputs = 1,
      hash_t hash_seed = kHashSeed);

  void SetShapeDeferred(const std::function<Shape()>& shape_fn);

  // Contructor used to create leaf nodes.
  MlirNode(
      OpKind op, Shape shape, size_t num_outputs = 1,
      hash_t hash_seed = kHashSeed);

  Shape GetOpShape(const std::function<Shape()>& shape_fn) const;

  // Retrieves the full shape of the IR Node.
  c10::ArrayRef<Shape> shapes() const override;

  // Retrieves the shape of the output at a given index.
  const Shape& shape(size_t output_index = 0) const override;

  const std::vector<Output>& operands() const override;

  const Output& operand(size_t i) const override;

  virtual MlirOpVector
  Lower(MlirFunction function, MlirLoweringContext* loctx) const = 0;

private:
  // Adds node's index output number as operand.
  void AddOperand(NodePtr node, size_t index = 0);

  std::vector<Shape> shapes_;
  // A node holds a real reference to its operands.
  std::vector<NodePtr> operands_;
  // Outputs do not hold references on the nodes, and neither do the uses, since
  // otherwise we get into circular reference counting.
  std::vector<Output> operands_as_outputs_;
};

} // namespace lazy
} // namespace torch
