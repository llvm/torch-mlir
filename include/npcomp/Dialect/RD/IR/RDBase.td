//===-------------------------------------------------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef RD_BASE
#define RD_BASE

include "mlir/IR/OpBase.td"

def RD_Dialect : Dialect {
  let name = "rd";
  let cppNamespace = "::mlir::NPCOMP::rd";
  let description = [{
The `rd` dialect represents parallel computation over collections.

Key features of the `rd` dialect include:
- Pure-functional abstractions, to enable easy analysis and optimization.
- A convenient Python DSL for a frontend to build up pipelines.
- Lowerings down to multiple coroutine-based streaming abstractions for efficient
  incremental computation over datasets larger than RAM.
- Programs generated by the RD abstraction scale down to mobile devices, or up to
  warehouse-scale distributed systems.
- Support for computation checkpointing and restoring to handle faults and to
  support dynamic re-optimiztion (a variation of on-stack replacement).

The RD dialect's Python DSL frontend is intentionally close to the `tf.data` system,
and from which it draws its name. (On a QWERTY keyboard, the two keys to the left of
`tf` are `rd`.)

While the abstractions supported by this dialect are designed to effectively support
training machine learning models (e.g. neural networks), the system is perfectly
suitable for more general computation.
  }];
}

//===----------------------------------------------------------------------===//
// Dialect types
//===----------------------------------------------------------------------===//

def RD_Dataset : DialectType<RD_Dialect,
    CPred<"$_self.isa<::mlir::NPCOMP::rd::DatasetType>()">, "Dataset type">,
    BuildableType<"$_builder.getType<::mlir::NPCOMP::rd::DatasetType>()"> {

  // let typeDescription = [{
  //   An immutable collection of values.

  //   A dataset is an abstract collection of values that can be manipulated in bulk using
  //   functional operators to build new datasets.

  //   In order to allow for efficient optimization and implementation, datasets are
  //   immutable and stateless. Once created, the data represented by a dataset never
  //   changes. To represent a new collection of data, operations on a dataset return a
  //   new dataset.

  //   To access data in a dataset, create an iterator which allows sequential access to
  //   the dataset.
  // }];
}

def RD_Iterator : DialectType<RD_Dialect,
    CPred<"$_self.isa<::mlir::NPCOMP::rd::IteratorType>()">, "Iterator type">,
    BuildableType<"$_builder.getType<::mlir::NPCOMP::rd::IteratorType>()"> {

  // let typeDescription = [{
  //   Sequential access to a collection of values.

  //   TODO(saeta): Write me!
  // }];
}

#endif // #ifndef RD_BASE
