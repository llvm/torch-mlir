//===-------------------------------------------------------*- tablegen -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Also available under a BSD-style license. See LICENSE.
//
// Operation summaries and descriptions were systematically derived from public
// API docstrings and are licensed accordingly:
//   https://github.com/pytorch/pytorch/blob/master/LICENSE
//===----------------------------------------------------------------------===//
//
// This file is automatically generated.  Please do not edit.
// Generated via:
// ```
// python -m torch_mlir.dialects.torch.importer.jit_ir.build_tools.torch_ods_gen
// ```
//
//===----------------------------------------------------------------------===//


def Torch_AtenTanhOp : Torch_Op<"aten.tanh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tanh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTanhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTanh_Op : Torch_Op<"aten.tanh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::tanh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTanh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardtanhOp : Torch_Op<"aten.hardtanh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardtanh : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min_val,
    AnyTorchScalarType:$max_val
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardtanhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenHardtanhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenHardtanh_Op : Torch_Op<"aten.hardtanh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::hardtanh_ : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min_val,
    AnyTorchScalarType:$max_val
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardtanh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenHardtanh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenReluOp : Torch_Op<"aten.relu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::relu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenReluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRelu_Op : Torch_Op<"aten.relu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::relu_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRelu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRelu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLeakyReluOp : Torch_Op<"aten.leaky_relu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::leaky_relu : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$negative_slope
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeakyReluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeakyReluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLeakyRelu_Op : Torch_Op<"aten.leaky_relu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::leaky_relu_ : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$negative_slope
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeakyRelu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeakyRelu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogOp : Torch_Op<"aten.log", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLogOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog_Op : Torch_Op<"aten.log_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::log_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSigmoidOp : Torch_Op<"aten.sigmoid", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sigmoid : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSigmoidOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSigmoidOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSigmoid_Op : Torch_Op<"aten.sigmoid_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sigmoid_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSigmoid_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSigmoid_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardsigmoidOp : Torch_Op<"aten.hardsigmoid", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardsigmoid : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardsigmoidOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardsigmoidOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardsigmoid_Op : Torch_Op<"aten.hardsigmoid_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::hardsigmoid_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardsigmoid_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardsigmoid_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardswishOp : Torch_Op<"aten.hardswish", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardswish : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardswishOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardswishOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardswish_Op : Torch_Op<"aten.hardswish_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::hardswish_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardswish_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardswish_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenErfOp : Torch_Op<"aten.erf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::erf : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenErfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenErfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenErf_Op : Torch_Op<"aten.erf_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::erf_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenErf_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenErf_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSiluOp : Torch_Op<"aten.silu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::silu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSiluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSiluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSilu_Op : Torch_Op<"aten.silu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::silu_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSilu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSilu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSinOp : Torch_Op<"aten.sin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sin : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSin_Op : Torch_Op<"aten.sin_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sin_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSin_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSin_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenExpOp : Torch_Op<"aten.exp", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::exp : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenExpOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenExp_Op : Torch_Op<"aten.exp_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::exp_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExp_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenExp_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCosOp : Torch_Op<"aten.cos", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cos : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCos_Op : Torch_Op<"aten.cos_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::cos_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCos_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCos_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNegOp : Torch_Op<"aten.neg", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::neg : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNegOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNegOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNeg_Op : Torch_Op<"aten.neg_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::neg_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeg_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNeg_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFloorOp : Torch_Op<"aten.floor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floor : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFloor_Op : Torch_Op<"aten.floor_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::floor_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloor_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloor_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCeilOp : Torch_Op<"aten.ceil", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ceil : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeilOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeilOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCeil_Op : Torch_Op<"aten.ceil_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ceil_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeil_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeil_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBitwiseNotOp : Torch_Op<"aten.bitwise_not", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_not : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseNotOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBitwiseNotOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBitwiseNot_Op : Torch_Op<"aten.bitwise_not_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_not_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseNot_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBitwiseNot_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSubTensorOp : Torch_Op<"aten.sub.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSubTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSub_TensorOp : Torch_Op<"aten.sub_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sub_.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSub_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSub_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMulTensorOp : Torch_Op<"aten.mul.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMul_TensorOp : Torch_Op<"aten.mul_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::mul_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMul_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMul_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDivTensorOp : Torch_Op<"aten.div.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDiv_TensorOp : Torch_Op<"aten.div_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::div_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiv_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDiv_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalOrOp : Torch_Op<"aten.logical_or", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logical_or : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalOrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalOrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalOr_Op : Torch_Op<"aten.logical_or_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::logical_or_ : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalOr_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalOr_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDivTensorModeOp : Torch_Op<"aten.div.Tensor_mode", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.Tensor_mode : (Tensor, Tensor, str?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchOptionalStringType:$rounding_mode
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivTensorModeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDivTensorModeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDiv_TensorModeOp : Torch_Op<"aten.div_.Tensor_mode", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::div_.Tensor_mode : (Tensor, Tensor, str?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchOptionalStringType:$rounding_mode
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiv_TensorModeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDiv_TensorModeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLerpTensorOp : Torch_Op<"aten.lerp.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lerp.Tensor : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$end,
    AnyTorchTensorType:$weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLerpTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLerpTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLerp_TensorOp : Torch_Op<"aten.lerp_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lerp_.Tensor : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$end,
    AnyTorchTensorType:$weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLerp_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLerp_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenEqTensorOp : Torch_Op<"aten.eq.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEq_TensorOp : Torch_Op<"aten.eq_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::eq_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEq_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEq_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGtTensorOp : Torch_Op<"aten.gt.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGt_TensorOp : Torch_Op<"aten.gt_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::gt_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGt_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGt_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLtTensorOp : Torch_Op<"aten.lt.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLt_TensorOp : Torch_Op<"aten.lt_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lt_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLt_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLt_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeTensorOp : Torch_Op<"aten.ne.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNe_TensorOp : Torch_Op<"aten.ne_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ne_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNe_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNe_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddScalarOp : Torch_Op<"aten.add.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAddScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAdd_ScalarOp : Torch_Op<"aten.add_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::add_.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdd_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAdd_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSubScalarOp : Torch_Op<"aten.sub.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSubScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSub_ScalarOp : Torch_Op<"aten.sub_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sub_.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSub_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSub_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMulScalarOp : Torch_Op<"aten.mul.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMul_ScalarOp : Torch_Op<"aten.mul_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::mul_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMul_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMul_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDivScalarOp : Torch_Op<"aten.div.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDiv_ScalarOp : Torch_Op<"aten.div_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::div_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiv_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDiv_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeScalarOp : Torch_Op<"aten.ne.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNe_ScalarOp : Torch_Op<"aten.ne_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ne_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNe_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNe_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEqScalarOp : Torch_Op<"aten.eq.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEq_ScalarOp : Torch_Op<"aten.eq_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::eq_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEq_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEq_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGtScalarOp : Torch_Op<"aten.gt.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGt_ScalarOp : Torch_Op<"aten.gt_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::gt_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGt_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGt_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGeScalarOp : Torch_Op<"aten.ge.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGe_ScalarOp : Torch_Op<"aten.ge_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ge_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGe_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGe_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLtScalarOp : Torch_Op<"aten.lt.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLt_ScalarOp : Torch_Op<"aten.lt_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lt_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLt_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLt_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLeScalarOp : Torch_Op<"aten.le.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::le.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLe_ScalarOp : Torch_Op<"aten.le_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::le_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLe_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLe_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFmodScalarOp : Torch_Op<"aten.fmod.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fmod.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFmodScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFmodScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFmod_ScalarOp : Torch_Op<"aten.fmod_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::fmod_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFmod_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFmod_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMaskedFillScalarOp : Torch_Op<"aten.masked_fill.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::masked_fill.Scalar : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedFillScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedFillScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMaskedFill_ScalarOp : Torch_Op<"aten.masked_fill_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::masked_fill_.Scalar : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedFill_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedFill_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClampOp : Torch_Op<"aten.clamp", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp : (Tensor, Scalar?, Scalar?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalScalarType:$min,
    AnyTorchOptionalScalarType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenClampOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClamp_Op : Torch_Op<"aten.clamp_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_ : (Tensor, Scalar?, Scalar?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalScalarType:$min,
    AnyTorchOptionalScalarType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClamp_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenClamp_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClampMinOp : Torch_Op<"aten.clamp_min", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp_min : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMin_Op : Torch_Op<"aten.clamp_min_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_min_ : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMin_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMin_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMaxOp : Torch_Op<"aten.clamp_max", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp_max : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMax_Op : Torch_Op<"aten.clamp_max_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_max_ : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMax_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMax_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLog2Op : Torch_Op<"aten.log2", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log2 : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog2Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog2Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog2_Op : Torch_Op<"aten.log2_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::log2_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog2_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog2_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSqrtOp : Torch_Op<"aten.sqrt", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sqrt : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqrtOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqrtOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSqrt_Op : Torch_Op<"aten.sqrt_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sqrt_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqrt_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqrt_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRsqrtOp : Torch_Op<"aten.rsqrt", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rsqrt : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRsqrtOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRsqrtOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRsqrt_Op : Torch_Op<"aten.rsqrt_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::rsqrt_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRsqrt_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRsqrt_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAbsOp : Torch_Op<"aten.abs", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::abs : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAbsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAbsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAbs_Op : Torch_Op<"aten.abs_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::abs_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAbs_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAbs_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenReciprocalOp : Torch_Op<"aten.reciprocal", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reciprocal : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReciprocalOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenReciprocalOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenReciprocal_Op : Torch_Op<"aten.reciprocal_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::reciprocal_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReciprocal_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenReciprocal_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBitwiseAndTensorOp : Torch_Op<"aten.bitwise_and.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_and.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseAndTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseAndTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseAnd_TensorOp : Torch_Op<"aten.bitwise_and_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_and_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseAnd_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseAnd_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenThresholdOp : Torch_Op<"aten.threshold", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::threshold : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$threshold,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenThresholdOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenThresholdOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenThreshold_Op : Torch_Op<"aten.threshold_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::threshold_ : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$threshold,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenThreshold_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenThreshold_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSquareOp : Torch_Op<"aten.square", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::square : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSquareOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSquareOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSquare_Op : Torch_Op<"aten.square_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::square_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSquare_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSquare_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenUnsqueezeOp : Torch_Op<"aten.unsqueeze", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unsqueeze : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnsqueezeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnsqueezeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUnsqueeze_Op : Torch_Op<"aten.unsqueeze_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::unsqueeze_ : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnsqueeze_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnsqueeze_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenZeroOp : Torch_Op<"aten.zero", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::zero : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZeroOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenZeroOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenZero_Op : Torch_Op<"aten.zero_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::zero_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZero_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenZero_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAddTensorOp : Torch_Op<"aten.add.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAddTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenAdd_TensorOp : Torch_Op<"aten.add_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::add_.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdd_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAdd_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAddcmulOp : Torch_Op<"aten.addcmul", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::addcmul : (Tensor, Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$tensor1,
    AnyTorchTensorType:$tensor2,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddcmulOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAddcmulOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenAddcdivOp : Torch_Op<"aten.addcdiv", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::addcdiv : (Tensor, Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$tensor1,
    AnyTorchTensorType:$tensor2,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddcdivOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAddcdivOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenMaximumOp : Torch_Op<"aten.maximum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::maximum : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaximumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMaximumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMinimumOp : Torch_Op<"aten.minimum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::minimum : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMinimumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMinimumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenRsubScalarOp : Torch_Op<"aten.rsub.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rsub.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRsubScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenRsubScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenGeluOp : Torch_Op<"aten.gelu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gelu : (Tensor, str) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_StringType:$approximate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPowTensorScalarOp : Torch_Op<"aten.pow.Tensor_Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pow.Tensor_Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$exponent
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPowTensorScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPowTensorScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenThresholdBackwardOp : Torch_Op<"aten.threshold_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::threshold_backward : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$threshold
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenThresholdBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenThresholdBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenFloorDivideOp : Torch_Op<"aten.floor_divide", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floor_divide : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloorDivideOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFloorDivideOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFill_ScalarOp : Torch_Op<"aten.fill_.Scalar", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::fill_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFill_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFill_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUniform_Op : Torch_Op<"aten.uniform_", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::uniform_ : (Tensor, float, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$from,
    Torch_FloatType:$to,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUniform_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenUniform_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenRandLikeOp : Torch_Op<"aten.rand_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rand_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenRandLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenBernoulliOp : Torch_Op<"aten.bernoulli", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bernoulli : (Tensor, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulliOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBernoulliOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBernoulli_FloatOp : Torch_Op<"aten.bernoulli_.float", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bernoulli_.float : (Tensor, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$p,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulli_FloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBernoulli_FloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenBernoulli_TensorOp : Torch_Op<"aten.bernoulli_.Tensor", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bernoulli_.Tensor : (Tensor, Tensor, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$p,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulli_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBernoulli_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenTriuOp : Torch_Op<"aten.triu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::triu : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$diagonal
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTriuOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTriuOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTriu_Op : Torch_Op<"aten.triu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::triu_ : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$diagonal
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTriu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTriu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenIndexPutOp : Torch_Op<"aten.index_put", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index_put : (Tensor, Tensor?[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIndexPut_Op : Torch_Op<"aten.index_put_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::index_put_ : (Tensor, Tensor?[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPut_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPut_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIndexPutHackedTwinOp : Torch_Op<"aten.index_put.hacked_twin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index_put.hacked_twin : (Tensor, Tensor[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPutHackedTwinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPutHackedTwinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIndexPut_HackedTwinOp : Torch_Op<"aten.index_put_.hacked_twin", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::index_put_.hacked_twin : (Tensor, Tensor[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPut_HackedTwinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPut_HackedTwinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenLinearOp : Torch_Op<"aten.linear", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linear : (Tensor, Tensor, Tensor?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinearOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLinearOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMmOp : Torch_Op<"aten.mm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mm : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mat2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddmmOp : Torch_Op<"aten.addmm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::addmm : (Tensor, Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mat1,
    AnyTorchTensorType:$mat2,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddmmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenAddmmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenMatmulOp : Torch_Op<"aten.matmul", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::matmul : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMatmulOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMatmulOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenConv2dOp : Torch_Op<"aten.conv2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv2d : (Tensor, Tensor, Tensor?, int[], int[], int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConv2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenConv2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenConvolutionOp : Torch_Op<"aten.convolution", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::convolution : (Tensor, Tensor, Tensor?, int[], int[], int[], bool, int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvolutionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 1);
    }
    void AtenConvolutionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 1);
    }
  }];
}

def Torch_AtenConvolutionOverrideableOp : Torch_Op<"aten.convolution_overrideable", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::convolution_overrideable : (Tensor, Tensor, Tensor?, int[], int[], int[], bool, int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvolutionOverrideableOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 1);
    }
    void AtenConvolutionOverrideableOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 1);
    }
  }];
}

def Torch_Aten_ConvolutionOp : Torch_Op<"aten._convolution", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_convolution : (Tensor, Tensor, Tensor?, int[], int[], int[], bool, int[], int, bool, bool, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    Torch_BoolType:$benchmark,
    Torch_BoolType:$deterministic,
    Torch_BoolType:$cudnn_enabled,
    Torch_BoolType:$allow_tf32
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ConvolutionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 13, 1);
    }
    void Aten_ConvolutionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 13, 1);
    }
  }];
}

def Torch_AtenFlipOp : Torch_Op<"aten.flip", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::flip : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFlipOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFlipOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNativeBatchNormOp : Torch_Op<"aten.native_batch_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_batch_norm : (Tensor, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, float) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    Torch_BoolType:$training,
    Torch_FloatType:$momentum,
    Torch_FloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeBatchNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 3);
    }
    void AtenNativeBatchNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 3);
    }
  }];
}

def Torch_AtenBatchNormOp : Torch_Op<"aten.batch_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::batch_norm : (Tensor, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    Torch_BoolType:$training,
    Torch_FloatType:$momentum,
    Torch_FloatType:$eps,
    Torch_BoolType:$cudnn_enabled
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBatchNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 1);
    }
    void AtenBatchNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 1);
    }
  }];
}

def Torch_AtenLayerNormOp : Torch_Op<"aten.layer_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::layer_norm : (Tensor, int[], Tensor?, Tensor?, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchListOfTorchIntType:$normalized_shape,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    Torch_FloatType:$eps,
    Torch_BoolType:$cudnn_enable
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLayerNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenLayerNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenNativeLayerNormOp : Torch_Op<"aten.native_layer_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_layer_norm : (Tensor, int[], Tensor?, Tensor?, float) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchListOfTorchIntType:$normalized_shape,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    Torch_FloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeLayerNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 3);
    }
    void AtenNativeLayerNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 3);
    }
  }];
}

def Torch_AtenMaxPool2dOp : Torch_Op<"aten.max_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool2d : (Tensor, int[], int[], int[], int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenMaxPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenMaxPool2dWithIndicesOp : Torch_Op<"aten.max_pool2d_with_indices", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool2d_with_indices : (Tensor, int[], int[], int[], int[], bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool2dWithIndicesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 2);
    }
    void AtenMaxPool2dWithIndicesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 2);
    }
  }];
}

def Torch_AtenMaxPool2dWithIndicesBackwardOp : Torch_Op<"aten.max_pool2d_with_indices_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool2d_with_indices_backward : (Tensor, Tensor, int[], int[], int[], int[], bool, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode,
    AnyTorchTensorType:$indices
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool2dWithIndicesBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenMaxPool2dWithIndicesBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenAvgPool2dOp : Torch_Op<"aten.avg_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::avg_pool2d : (Tensor, int[], int[], int[], bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    Torch_BoolType:$ceil_mode,
    Torch_BoolType:$count_include_pad,
    AnyTorchOptionalIntType:$divisor_override
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAvgPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenAvgPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenSoftmaxIntOp : Torch_Op<"aten.softmax.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::softmax.int : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSoftmaxIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSoftmaxIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLogSoftmaxIntOp : Torch_Op<"aten.log_softmax.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log_softmax.int : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogSoftmaxIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLogSoftmaxIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_LogSoftmaxOp : Torch_Op<"aten._log_softmax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_log_softmax : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$half_to_float
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_LogSoftmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_LogSoftmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAdaptiveAvgPool2dOp : Torch_Op<"aten.adaptive_avg_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_avg_pool2d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveAvgPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAdaptiveAvgPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTopkOp : Torch_Op<"aten.topk", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::topk : (Tensor, int, int, bool, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$k,
    Torch_IntType:$dim,
    Torch_BoolType:$largest,
    Torch_BoolType:$sorted
  );
  let results = (outs
    AnyTorchTensorType:$values,
    AnyTorchTensorType:$indices
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTopkOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 2);
    }
    void AtenTopkOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 2);
    }
  }];
}

def Torch_AtenTransposeIntOp : Torch_Op<"aten.transpose.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::transpose.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim0,
    Torch_IntType:$dim1
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTransposeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenTransposeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenPermuteOp : Torch_Op<"aten.permute", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::permute : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPermuteOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPermuteOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBmmOp : Torch_Op<"aten.bmm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bmm : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mat2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBmmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBmmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCumsumOp : Torch_Op<"aten.cumsum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cumsum : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCumsumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenCumsumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenFloorDivideScalarOp : Torch_Op<"aten.floor_divide.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floor_divide.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloorDivideScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFloorDivideScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogsumexpOp : Torch_Op<"aten.logsumexp", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logsumexp : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogsumexpOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLogsumexpOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMeanDimOp : Torch_Op<"aten.mean.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mean.dim : (Tensor, int[], bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMeanDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenMeanDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_Aten__And__TensorOp : Torch_Op<"aten.__and__.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__and__.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__And__TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__And__TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_SoftmaxOp : Torch_Op<"aten._softmax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_softmax : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$half_to_float
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SoftmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_SoftmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMeanOp : Torch_Op<"aten.mean", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mean : (Tensor, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMeanOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMeanOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenStdOp : Torch_Op<"aten.std", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::std : (Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_BoolType:$unbiased
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStdOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenStdOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenVarOp : Torch_Op<"aten.var", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var : (Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_BoolType:$unbiased
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenVarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenVarDimOp : Torch_Op<"aten.var.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var.dim : (Tensor, int[], bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$unbiased,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenVarDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenNllLossForwardOp : Torch_Op<"aten.nll_loss_forward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nll_loss_forward : (Tensor, Tensor, Tensor?, int, int) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index
  );
  let results = (outs
    AnyTorchTensorType:$output,
    AnyTorchTensorType:$total_weight
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNllLossForwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 2);
    }
    void AtenNllLossForwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 2);
    }
  }];
}

def Torch_AtenNllLossBackwardOp : Torch_Op<"aten.nll_loss_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nll_loss_backward : (Tensor, Tensor, Tensor, Tensor?, int, int, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index,
    AnyTorchTensorType:$total_weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNllLossBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenNllLossBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenBincountOp : Torch_Op<"aten.bincount", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bincount : (Tensor, Tensor?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalTensorType:$weights,
    Torch_IntType:$minlength
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBincountOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBincountOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLinalgVectorNormOp : Torch_Op<"aten.linalg_vector_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linalg_vector_norm : (Tensor, Scalar, int[]?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$ord,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinalgVectorNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenLinalgVectorNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenConstantPadNdOp : Torch_Op<"aten.constant_pad_nd", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::constant_pad_nd : (Tensor, int[], Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$pad,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConstantPadNdOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenConstantPadNdOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenPadOp : Torch_Op<"aten.pad", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pad : (Tensor, int[], str, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$pad,
    Torch_StringType:$mode,
    AnyTorchOptionalFloatType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPadOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenPadOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSqueezeDimOp : Torch_Op<"aten.squeeze.dim", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze.dim : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSqueezeDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSqueezeOp : Torch_Op<"aten.squeeze", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqueezeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFlattenUsingIntsOp : Torch_Op<"aten.flatten.using_ints", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::flatten.using_ints : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$start_dim,
    Torch_IntType:$end_dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFlattenUsingIntsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenFlattenUsingIntsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDimOp : Torch_Op<"aten.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::dim : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSizeOp : Torch_Op<"aten.size", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::size : (Tensor) -> (int[])`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchListOfTorchIntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSizeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSizeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenBoolTensorOp : Torch_Op<"aten.Bool.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Bool.Tensor : (Tensor) -> (bool)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBoolTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBoolTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIsFloatingPointOp : Torch_Op<"aten.is_floating_point", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::is_floating_point : (Tensor) -> (bool)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIsFloatingPointOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIsFloatingPointOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenOnesOp : Torch_Op<"aten.ones", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ones : (int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenOnesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenOnesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenNewOnesOp : Torch_Op<"aten.new_ones", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_ones : (Tensor, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewOnesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenNewOnesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenZerosOp : Torch_Op<"aten.zeros", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::zeros : (int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZerosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenZerosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenNewZerosOp : Torch_Op<"aten.new_zeros", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_zeros : (Tensor, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewZerosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenNewZerosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenTensorOp : Torch_Op<"aten.tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor : (t[], int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListType:$data,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenTensorBoolOp : Torch_Op<"aten.tensor.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor.bool : (bool, int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_BoolType:$t,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenTensorIntOp : Torch_Op<"aten.tensor.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor.int : (int, int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_IntType:$t,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_Aten_ShapeAsTensorOp : Torch_Op<"aten._shape_as_tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_shape_as_tensor : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ShapeAsTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void Aten_ShapeAsTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAllOp : Torch_Op<"aten.all", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::all : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAllOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAllOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAllBoolOp : Torch_Op<"aten.all.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::all.bool : (bool[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchBoolType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAllBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAllBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAnyOp : Torch_Op<"aten.any", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::any : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAnyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAnyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAnyDimOp : Torch_Op<"aten.any.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::any.dim : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAnyDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAnyDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenArangeOp : Torch_Op<"aten.arange", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::arange : (Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$end,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenArangeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenArangeStartOp : Torch_Op<"aten.arange.start", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::arange.start : (Scalar, Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeStartOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenArangeStartOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenArangeStartStepOp : Torch_Op<"aten.arange.start_step", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::arange.start_step : (Scalar, Scalar, Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    AnyTorchScalarType:$step,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeStartStepOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenArangeStartStepOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenArangeStartOutOp : Torch_Op<"aten.arange.start_out", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::arange.start_out : (Scalar, Scalar, Scalar, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    AnyTorchScalarType:$step,
    AnyTorchTensorType:$out
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeStartOutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenArangeStartOutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenArgmaxOp : Torch_Op<"aten.argmax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::argmax : (Tensor, int?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArgmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenArgmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenBucketizeTensorOp : Torch_Op<"aten.bucketize.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bucketize.Tensor : (Tensor, Tensor, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$boundaries,
    Torch_BoolType:$out_int32,
    Torch_BoolType:$right
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBucketizeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenBucketizeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenCloneOp : Torch_Op<"aten.clone", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clone : (Tensor, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCloneOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenCloneOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenContiguousOp : Torch_Op<"aten.contiguous", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::contiguous : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenContiguousOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenContiguousOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCopy_Op : Torch_Op<"aten.copy_", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::copy_ : (Tensor, Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_BoolType:$non_blocking
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCopy_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenCopy_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_ToCopyOp : Torch_Op<"aten._to_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_to_copy : (Tensor, int?, int?, Device?, bool?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    Torch_BoolType:$non_blocking,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ToCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void Aten_ToCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenDetachOp : Torch_Op<"aten.detach", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::detach : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDetachOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDetachOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenEmbeddingOp : Torch_Op<"aten.embedding", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::embedding : (Tensor, Tensor, int, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$weight,
    AnyTorchTensorType:$indices,
    Torch_IntType:$padding_idx,
    Torch_BoolType:$scale_grad_by_freq,
    Torch_BoolType:$sparse
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmbeddingOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenEmbeddingOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenEmptyLikeOp : Torch_Op<"aten.empty_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::empty_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmptyLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEmptyLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenNewEmptyOp : Torch_Op<"aten.new_empty", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_empty : (Tensor, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewEmptyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenNewEmptyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenZerosLikeOp : Torch_Op<"aten.zeros_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::zeros_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZerosLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenZerosLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenOnesLikeOp : Torch_Op<"aten.ones_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ones_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenOnesLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenOnesLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenEmptyMemoryFormatOp : Torch_Op<"aten.empty.memory_format", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::empty.memory_format : (int[], int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmptyMemoryFormatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEmptyMemoryFormatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenExpandOp : Torch_Op<"aten.expand", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expand : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    Torch_BoolType:$implicit
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpandOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenExpandOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenExpandAsOp : Torch_Op<"aten.expand_as", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expand_as : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpandAsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenExpandAsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBroadcastToOp : Torch_Op<"aten.broadcast_to", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::broadcast_to : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBroadcastToOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBroadcastToOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenIndexTensorOp : Torch_Op<"aten.index.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index.Tensor : (Tensor, Tensor?[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenIndexTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenIndexSelectOp : Torch_Op<"aten.index_select", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index_select : (Tensor, int, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexSelectOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenIndexSelectOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_IndexPutImpl_Op : Torch_Op<"aten._index_put_impl_", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::_index_put_impl_ : (Tensor, Tensor?[], Tensor, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate,
    Torch_BoolType:$unsafe
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_IndexPutImpl_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void Aten_IndexPutImpl_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenItemOp : Torch_Op<"aten.item", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::item : (Tensor) -> (Scalar)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenItemOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenItemOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenMaskedSelectOp : Torch_Op<"aten.masked_select", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::masked_select : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedSelectOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMaskedSelectOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNumelOp : Torch_Op<"aten.numel", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::numel : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNumelOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNumelOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRepeatOp : Torch_Op<"aten.repeat", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::repeat : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$repeats
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRepeatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRepeatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenReshapeOp : Torch_Op<"aten.reshape", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reshape : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$shape
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReshapeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenReshapeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_ReshapeAliasOp : Torch_Op<"aten._reshape_alias", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_reshape_alias : (Tensor, int[], int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ReshapeAliasOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_ReshapeAliasOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenResize_Op : Torch_Op<"aten.resize_", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::resize_ : (Tensor, int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenResize_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenResize_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSelectIntOp : Torch_Op<"aten.select.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSelectIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSelectScatterOp : Torch_Op<"aten.select_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select_scatter : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSelectScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSizeIntOp : Torch_Op<"aten.size.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::size.int : (Tensor, int) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSizeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSizeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenStackOp : Torch_Op<"aten.stack", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::stack : (Tensor[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTensorType:$tensors,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStackOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenStackOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSumOp : Torch_Op<"aten.sum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sum : (Tensor, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSumDimIntListOp : Torch_Op<"aten.sum.dim_IntList", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sum.dim_IntList : (Tensor, int[]?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSumDimIntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSumDimIntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenMaxOp : Torch_Op<"aten.max", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenMaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenMaxDimOp : Torch_Op<"aten.max.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max.dim : (Tensor, int, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$values,
    AnyTorchTensorType:$indices
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 2);
    }
    void AtenMaxDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 2);
    }
  }];
}

def Torch_AtenToDtypeOp : Torch_Op<"aten.to.dtype", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.dtype : (Tensor, int, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dtype,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToDtypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenToDtypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenToDtypeLayoutOp : Torch_Op<"aten.to.dtype_layout", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.dtype_layout : (Tensor, int?, int?, Device?, bool?, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToDtypeLayoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenToDtypeLayoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenToOtherOp : Torch_Op<"aten.to.other", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.other : (Tensor, Tensor, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToOtherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenToOtherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenToPrimDeviceOp : Torch_Op<"aten.to.prim_Device", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.prim_Device : (Tensor, Device?, int?, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalIntType:$dtype,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToPrimDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenToPrimDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenTypeAsOp : Torch_Op<"aten.type_as", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::type_as : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTypeAsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTypeAsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenViewOp : Torch_Op<"aten.view", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenViewOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten_UnsafeViewOp : Torch_Op<"aten._unsafe_view", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_unsafe_view : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_UnsafeViewOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_UnsafeViewOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenWhereSelfOp : Torch_Op<"aten.where.self", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.self : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereSelfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereSelfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenWhereScalarOp : Torch_Op<"aten.where.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchScalarType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenWhereScalarOtherOp : Torch_Op<"aten.where.ScalarOther", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.ScalarOther : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereScalarOtherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereScalarOtherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenWhereScalarSelfOp : Torch_Op<"aten.where.ScalarSelf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.ScalarSelf : (Tensor, Scalar, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchScalarType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereScalarSelfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereScalarSelfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSliceTensorOp : Torch_Op<"aten.slice.Tensor", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice.Tensor : (Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenSliceTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenSliceScatterOp : Torch_Op<"aten.slice_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice_scatter : (Tensor, Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenSliceScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenLenTensorOp : Torch_Op<"aten.len.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::len.Tensor : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$t
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLenTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLenTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCpuOp : Torch_Op<"aten.cpu", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cpu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCpuOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCpuOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenGatherOp : Torch_Op<"aten.gather", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gather : (Tensor, int, Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    Torch_BoolType:$sparse_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGatherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenGatherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatterAddOp : Torch_Op<"aten.scatter_add", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scatter_add : (Tensor, int, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    AnyTorchTensorType:$src
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterAddOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatterAddOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIntImplicitOp : Torch_Op<"aten.IntImplicit", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::IntImplicit : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntImplicitOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntImplicitOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTensorFloatOp : Torch_Op<"aten.tensor.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor.float : (float, int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_FloatType:$t,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIntTensorOp : Torch_Op<"aten.Int.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.Tensor : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFloatTensorOp : Torch_Op<"aten.Float.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Float.Tensor : (Tensor) -> (float)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenDropoutOp : Torch_Op<"aten.dropout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::dropout : (Tensor, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    Torch_FloatType:$p,
    Torch_BoolType:$train
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDropoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDropoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDropout_Op : Torch_Op<"aten.dropout_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::dropout_ : (Tensor, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$p,
    Torch_BoolType:$train
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDropout_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDropout_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenNativeDropoutOp : Torch_Op<"aten.native_dropout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_dropout : (Tensor, float, bool?) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    Torch_FloatType:$p,
    AnyTorchOptionalBoolType:$train
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeDropoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 2);
    }
    void AtenNativeDropoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 2);
    }
  }];
}

def Torch_AtenTOp : Torch_Op<"aten.t", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::t : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNumpyTOp : Torch_Op<"aten.numpy_T", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::numpy_T : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNumpyTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNumpyTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFullOp : Torch_Op<"aten.full", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::full : (int[], Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchScalarType:$fill_value,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFullOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenFullOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenFullLikeOp : Torch_Op<"aten.full_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::full_like : (Tensor, Scalar, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$fill_value,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFullLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenFullLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenBaddbmmOp : Torch_Op<"aten.baddbmm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::baddbmm : (Tensor, Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$batch1,
    AnyTorchTensorType:$batch2,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBaddbmmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenBaddbmmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenBaddbmm_Op : Torch_Op<"aten.baddbmm_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::baddbmm_ : (Tensor, Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$batch1,
    AnyTorchTensorType:$batch2,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBaddbmm_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenBaddbmm_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenAliasCopyOp : Torch_Op<"aten.alias_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::alias_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAliasCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAliasCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAsStridedCopyOp : Torch_Op<"aten.as_strided_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::as_strided_copy : (Tensor, int[], int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchOptionalIntType:$storage_offset
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsStridedCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAsStridedCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenDiagonalCopyOp : Torch_Op<"aten.diagonal_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::diagonal_copy : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$offset,
    Torch_IntType:$dim1,
    Torch_IntType:$dim2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiagonalCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenDiagonalCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenExpandCopyOp : Torch_Op<"aten.expand_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expand_copy : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    Torch_BoolType:$implicit
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpandCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenExpandCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenPermuteCopyOp : Torch_Op<"aten.permute_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::permute_copy : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPermuteCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPermuteCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_ReshapeAliasCopyOp : Torch_Op<"aten._reshape_alias_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_reshape_alias_copy : (Tensor, int[], int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ReshapeAliasCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_ReshapeAliasCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSelectCopyIntOp : Torch_Op<"aten.select_copy.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select_copy.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectCopyIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSelectCopyIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDetachCopyOp : Torch_Op<"aten.detach_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::detach_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDetachCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDetachCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSliceCopyTensorOp : Torch_Op<"aten.slice_copy.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice_copy.Tensor : (Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceCopyTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenSliceCopyTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenSqueezeCopyOp : Torch_Op<"aten.squeeze_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqueezeCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSqueezeCopyDimOp : Torch_Op<"aten.squeeze_copy.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze_copy.dim : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeCopyDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSqueezeCopyDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTCopyOp : Torch_Op<"aten.t_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::t_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTransposeCopyIntOp : Torch_Op<"aten.transpose_copy.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::transpose_copy.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim0,
    Torch_IntType:$dim1
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTransposeCopyIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenTransposeCopyIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenUnsqueezeCopyOp : Torch_Op<"aten.unsqueeze_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unsqueeze_copy : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnsqueezeCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnsqueezeCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenViewCopyOp : Torch_Op<"aten.view_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view_copy : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenViewCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenViewCopyDtypeOp : Torch_Op<"aten.view_copy.dtype", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view_copy.dtype : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewCopyDtypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenViewCopyDtypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUnfoldCopyOp : Torch_Op<"aten.unfold_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unfold_copy : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dimension,
    Torch_IntType:$size,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnfoldCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenUnfoldCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSelectScatterOp : Torch_Op<"aten.select_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select_scatter : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSelectScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSliceScatterOp : Torch_Op<"aten.slice_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice_scatter : (Tensor, Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenSliceScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenDiagonalScatterOp : Torch_Op<"aten.diagonal_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::diagonal_scatter : (Tensor, Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$offset,
    Torch_IntType:$dim1,
    Torch_IntType:$dim2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiagonalScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenDiagonalScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenAsStridedScatterOp : Torch_Op<"aten.as_strided_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::as_strided_scatter : (Tensor, Tensor, int[], int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchOptionalIntType:$storage_offset
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsStridedScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenAsStridedScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_Aten_UnsafeViewCopyOp : Torch_Op<"aten._unsafe_view_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_unsafe_view_copy : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_UnsafeViewCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_UnsafeViewCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten__Contains__StrOp : Torch_Op<"aten.__contains__.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__contains__.str : (Dict(str, t), str) -> (bool)`";
  let arguments = (ins
    Torch_DictType:$dict,
    Torch_StringType:$key
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Contains__StrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Contains__StrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Contains__IntListOp : Torch_Op<"aten.__contains__.int_list", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__contains__.int_list : (int[], int) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$l,
    Torch_IntType:$item
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Contains__IntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Contains__IntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Getitem__DictStrOp : Torch_Op<"aten.__getitem__.Dict_str", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__getitem__.Dict_str : (Dict(str, t), str) -> (t)`";
  let arguments = (ins
    Torch_DictType:$self,
    Torch_StringType:$key
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Getitem__DictStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Getitem__DictStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten_SetItemStrOp : Torch_Op<"aten._set_item.str", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::_set_item.str : (Dict(str, t), str, t) -> ()`";
  let arguments = (ins
    Torch_DictType:$l,
    Torch_StringType:$idx,
    AnyTorchType:$v
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SetItemStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 0);
    }
    void Aten_SetItemStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 0);
    }
  }];
}

def Torch_AtenKeysStrOp : Torch_Op<"aten.keys.str", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::keys.str : (Dict(str, t)) -> (str[])`";
  let arguments = (ins
    Torch_DictType:$self
  );
  let results = (outs
    AnyTorchListOfTorchStringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenKeysStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenKeysStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenGetDefaultStrOp : Torch_Op<"aten.get.default_str", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::get.default_str : (Dict(str, t), str, t) -> (t)`";
  let arguments = (ins
    Torch_DictType:$self,
    Torch_StringType:$key,
    AnyTorchType:$default_value
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGetDefaultStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenGetDefaultStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDeleteDictStrOp : Torch_Op<"aten.Delete.Dict_str", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::Delete.Dict_str : (Dict(str, t), str) -> ()`";
  let arguments = (ins
    Torch_DictType:$self,
    Torch_StringType:$key
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDeleteDictStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 0);
    }
    void AtenDeleteDictStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 0);
    }
  }];
}

def Torch_AtenCatOp : Torch_Op<"aten.cat", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cat : (Tensor[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTensorType:$tensors,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenCatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAppendTOp : Torch_Op<"aten.append.t", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::append.t : (t[], t) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$self,
    AnyTorchType:$el
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAppendTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAppendTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddTOp : Torch_Op<"aten.add.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.t : (t[], t[]) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$a,
    AnyTorchListType:$b
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEqIntListOp : Torch_Op<"aten.eq.int_list", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.int_list : (int[], int[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$a,
    AnyTorchListOfTorchIntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqIntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqIntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenListTOp : Torch_Op<"aten.list.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::list.t : (t[]) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$l
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenListTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenListTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSliceTOp : Torch_Op<"aten.slice.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice.t : (t[], int?, int?, int) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$l,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSliceTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenInsertTOp : Torch_Op<"aten.insert.t", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::insert.t : (t[], int, t) -> ()`";
  let arguments = (ins
    AnyTorchListType:$self,
    Torch_IntType:$idx,
    AnyTorchType:$el
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenInsertTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 0);
    }
    void AtenInsertTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 0);
    }
  }];
}

def Torch_AtenNeIntListOp : Torch_Op<"aten.ne.int_list", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.int_list : (int[], int[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$a,
    AnyTorchListOfTorchIntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeIntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeIntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAnyBoolOp : Torch_Op<"aten.any.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::any.bool : (bool[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchBoolType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAnyBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAnyBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAddStrOp : Torch_Op<"aten.add.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.str : (str, str) -> (str)`";
  let arguments = (ins
    Torch_StringType:$a,
    Torch_StringType:$b
  );
  let results = (outs
    Torch_StringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEqStrOp : Torch_Op<"aten.eq.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.str : (str, str) -> (bool)`";
  let arguments = (ins
    Torch_StringType:$a,
    Torch_StringType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLenStrOp : Torch_Op<"aten.len.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::len.str : (str) -> (int)`";
  let arguments = (ins
    Torch_StringType:$s
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLenStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLenStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenStrOp : Torch_Op<"aten.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::str : (t) -> (str)`";
  let arguments = (ins
    AnyTorchType:$elem
  );
  let results = (outs
    Torch_StringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFormatOp : Torch_Op<"aten.format", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::format : (...) -> (str)`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
    Torch_StringType:$result
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands)) `->` qualified(type($result))";
}

def Torch_AtenJoinOp : Torch_Op<"aten.join", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::join : (str, str[]) -> (str)`";
  let arguments = (ins
    Torch_StringType:$self,
    AnyTorchListOfTorchStringType:$values
  );
  let results = (outs
    Torch_StringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenJoinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenJoinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFloatScalarOp : Torch_Op<"aten.Float.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Float.Scalar : (Scalar) -> (float)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFloatStrOp : Torch_Op<"aten.Float.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Float.str : (str) -> (float)`";
  let arguments = (ins
    Torch_StringType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIntFloatOp : Torch_Op<"aten.Int.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.float : (float) -> (int)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIntScalarOp : Torch_Op<"aten.Int.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.Scalar : (Scalar) -> (int)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__RangeLengthOp : Torch_Op<"aten.__range_length", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__range_length : (int, int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$lo,
    Torch_IntType:$hi,
    Torch_IntType:$step
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__RangeLengthOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten__RangeLengthOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__DeriveIndexOp : Torch_Op<"aten.__derive_index", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__derive_index : (int, int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$index,
    Torch_IntType:$start,
    Torch_IntType:$step
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__DeriveIndexOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten__DeriveIndexOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGtIntOp : Torch_Op<"aten.gt.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGeIntOp : Torch_Op<"aten.ge.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLtIntOp : Torch_Op<"aten.lt.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLeIntOp : Torch_Op<"aten.le.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::le.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNeIntOp : Torch_Op<"aten.ne.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEqIntOp : Torch_Op<"aten.eq.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFloordivIntOp : Torch_Op<"aten.floordiv.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floordiv.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloordivIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFloordivIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenRemainderIntOp : Torch_Op<"aten.remainder.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::remainder.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRemainderIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRemainderIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenAddIntOp : Torch_Op<"aten.add.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSubIntOp : Torch_Op<"aten.sub.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSubIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenMulIntOp : Torch_Op<"aten.mul.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNegIntOp : Torch_Op<"aten.neg.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::neg.int : (int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNegIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNegIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLogIntOp : Torch_Op<"aten.log.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log.int : (int) -> (float)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLogIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAddFloatIntOp : Torch_Op<"aten.add.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.float_int : (float, int) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSubFloatOp : Torch_Op<"aten.sub.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.float : (float, float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSubFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMulFloatOp : Torch_Op<"aten.mul.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.float : (float, float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDivFloatOp : Torch_Op<"aten.div.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.float : (float, float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNegFloatOp : Torch_Op<"aten.neg.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::neg.float : (float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNegFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNegFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenEqFloatOp : Torch_Op<"aten.eq.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGtFloatOp : Torch_Op<"aten.gt.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGeFloatOp : Torch_Op<"aten.ge.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLtFloatOp : Torch_Op<"aten.lt.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLtFloatIntOp : Torch_Op<"aten.lt.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGeFloatIntOp : Torch_Op<"aten.ge.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeFloatIntOp : Torch_Op<"aten.ne.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGtFloatIntOp : Torch_Op<"aten.gt.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten__And__BoolOp : Torch_Op<"aten.__and__.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__and__.bool : (bool, bool) -> (bool)`";
  let arguments = (ins
    Torch_BoolType:$a,
    Torch_BoolType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__And__BoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__And__BoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeBoolOp : Torch_Op<"aten.ne.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.bool : (bool, bool) -> (bool)`";
  let arguments = (ins
    Torch_BoolType:$a,
    Torch_BoolType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Is__Op : Torch_Op<"aten.__is__", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__is__ : (t1, t2) -> (bool)`";
  let arguments = (ins
    AnyTorchType:$self,
    AnyTorchType:$obj
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Is__Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Is__Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Isnot__Op : Torch_Op<"aten.__isnot__", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__isnot__ : (t1, t2) -> (bool)`";
  let arguments = (ins
    AnyTorchType:$self,
    AnyTorchType:$obj
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Isnot__Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Isnot__Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Not__Op : Torch_Op<"aten.__not__", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__not__ : (bool) -> (bool)`";
  let arguments = (ins
    Torch_BoolType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Not__Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void Aten__Not__Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLenTOp : Torch_Op<"aten.len.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::len.t : (t[]) -> (int)`";
  let arguments = (ins
    AnyTorchListType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLenTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLenTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_Aten__Getitem__TOp : Torch_Op<"aten.__getitem__.t", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__getitem__.t : (t[], int) -> (t)`";
  let arguments = (ins
    AnyTorchListType:$list,
    Torch_IntType:$idx
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Getitem__TOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Getitem__TOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_Aten_SetItemTOp : Torch_Op<"aten._set_item.t", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::_set_item.t : (t[], int, t) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$l,
    Torch_IntType:$idx,
    AnyTorchType:$el
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SetItemTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_SetItemTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDivOp : Torch_Op<"aten.div", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div : (Scalar, Scalar) -> (float)`";
  let arguments = (ins
    AnyTorchScalarType:$a,
    AnyTorchScalarType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddOp : Torch_Op<"aten.add", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add : (Scalar, Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a,
    AnyTorchScalarType:$b
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSqrtIntOp : Torch_Op<"aten.sqrt.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sqrt.int : (int) -> (float)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqrtIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqrtIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenBoolFloatOp : Torch_Op<"aten.Bool.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Bool.float : (float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBoolFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBoolFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenBoolIntOp : Torch_Op<"aten.Bool.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Bool.int : (int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBoolIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBoolIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEqDeviceOp : Torch_Op<"aten.eq.device", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.device : (Device, Device) -> (bool)`";
  let arguments = (ins
    Torch_DeviceType:$a,
    Torch_DeviceType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCeilFloatOp : Torch_Op<"aten.ceil.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ceil.float : (float) -> (int)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeilFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeilFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenScalarImplicitOp : Torch_Op<"aten.ScalarImplicit", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ScalarImplicit : (Tensor) -> (Scalar)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScalarImplicitOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenScalarImplicitOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_Aten_SoftmaxBackwardDataOp : Torch_Op<"aten._softmax_backward_data", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_softmax_backward_data : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output,
    Torch_IntType:$dim,
    Torch_IntType:$input_dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SoftmaxBackwardDataOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void Aten_SoftmaxBackwardDataOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenTanhBackwardOp : Torch_Op<"aten.tanh_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tanh_backward : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanhBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTanhBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGeluBackwardOp : Torch_Op<"aten.gelu_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gelu_backward : (Tensor, Tensor, str) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    Torch_StringType:$approximate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeluBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenGeluBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_LogSoftmaxBackwardDataOp : Torch_Op<"aten._log_softmax_backward_data", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_log_softmax_backward_data : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output,
    Torch_IntType:$dim,
    Torch_IntType:$input_dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_LogSoftmaxBackwardDataOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void Aten_LogSoftmaxBackwardDataOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenNativeLayerNormBackwardOp : Torch_Op<"aten.native_layer_norm_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_layer_norm_backward : (Tensor, Tensor, int[], Tensor, Tensor, Tensor?, Tensor?, bool[]) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_out,
    AnyTorchTensorType:$input,
    AnyTorchListOfTorchIntType:$normalized_shape,
    AnyTorchTensorType:$mean,
    AnyTorchTensorType:$rstd,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchBoolType:$output_mask
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeLayerNormBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 3);
    }
    void AtenNativeLayerNormBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 3);
    }
  }];
}

def Torch_AtenEmbeddingDenseBackwardOp : Torch_Op<"aten.embedding_dense_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::embedding_dense_backward : (Tensor, Tensor, int, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$indices,
    Torch_IntType:$num_weights,
    Torch_IntType:$padding_idx,
    Torch_BoolType:$scale_grad_by_freq
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmbeddingDenseBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenEmbeddingDenseBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenNativeBatchNormBackwardOp : Torch_Op<"aten.native_batch_norm_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_batch_norm_backward : (Tensor, Tensor, Tensor?, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, bool[]) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_out,
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    AnyTorchOptionalTensorType:$save_mean,
    AnyTorchOptionalTensorType:$save_invstd,
    Torch_BoolType:$train,
    Torch_FloatType:$eps,
    AnyTorchListOfTorchBoolType:$output_mask
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeBatchNormBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 10, 3);
    }
    void AtenNativeBatchNormBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 10, 3);
    }
  }];
}

def Torch_AtenNativeDropoutBackwardOp : Torch_Op<"aten.native_dropout_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_dropout_backward : (Tensor, Tensor, float) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$mask,
    Torch_FloatType:$scale
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeDropoutBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenNativeDropoutBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_PrimLayoutOp : Torch_Op<"prim.layout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::layout : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimLayoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimLayoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimTupleIndexOp : Torch_Op<"prim.TupleIndex", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::TupleIndex : (Any, int) -> (Any)`";
  let arguments = (ins
    AnyTorchType:$tup,
    Torch_IntType:$i
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimTupleIndexOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimTupleIndexOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_PrimDeviceOp : Torch_Op<"prim.device", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::device : (Tensor) -> (Device)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_DeviceType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimDtypeOp : Torch_Op<"prim.dtype", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::dtype : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimDtypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimDtypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimTupleUnpackOp : Torch_Op<"prim.TupleUnpack", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::TupleUnpack : (Any) -> (...)`";
  let arguments = (ins
    AnyTorchType:$tup
  );
  let results = (outs
    Variadic<AnyTorchType>:$results
  );
  let assemblyFormat = "$tup attr-dict `:` qualified(type($tup)) `->` qualified(type($results))";
  let hasCanonicalizer = 1;
}

def Torch_PrimNumToTensorScalarOp : Torch_Op<"prim.NumToTensor.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::NumToTensor.Scalar : (Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimNumToTensorScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimNumToTensorScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimMinSelfIntOp : Torch_Op<"prim.min.self_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::min.self_int : (int[]) -> (int)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMinSelfIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimMinSelfIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimMinIntOp : Torch_Op<"prim.min.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::min.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMinIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimMinIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_PrimMaxSelfIntOp : Torch_Op<"prim.max.self_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::max.self_int : (int[]) -> (int)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMaxSelfIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimMaxSelfIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimMaxIntOp : Torch_Op<"prim.max.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::max.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMaxIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimMaxIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimRaiseExceptionOp : Torch_Op<"prim.RaiseException", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::RaiseException : (str, str?) -> ()`";
  let arguments = (ins
    Torch_StringType:$msg,
    AnyTorchOptionalStringType:$cls
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimRaiseExceptionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 0);
    }
    void PrimRaiseExceptionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 0);
    }
  }];
}

def Torch_PrimUninitializedOp : Torch_Op<"prim.Uninitialized", [
    NoSideEffect,
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::Uninitialized : () -> (Any)`";
  let arguments = (ins
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimUninitializedOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 0, 1);
    }
    void PrimUninitializedOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 0, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_PrimUncheckedCastOp : Torch_Op<"prim.unchecked_cast", [
    DeclareOpInterfaceMethods<CastOpInterface>,
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::unchecked_cast : (t) -> (t)`";
  let arguments = (ins
    AnyTorchType:$x
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimUncheckedCastOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimUncheckedCastOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimPrintOp : Torch_Op<"prim.Print", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::Print : (...) -> ()`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands))";
}

def Torch_PrimTolistOp : Torch_Op<"prim.tolist", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::tolist : (...) -> (...)`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
    Variadic<AnyTorchType>:$results
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands)) `->` qualified(type($results))";
}

def Torch_PrimAbsScalarOp : Torch_Op<"prim.abs.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::abs.Scalar : (Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimAbsScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimAbsScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_QuantizedLinearOp : Torch_Op<"quantized.linear", [
    HasValueSemantics,
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `quantized::linear : (Tensor, __torch__.torch.classes.quantized.LinearPackedParamsBase, float, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$X,
    Torch_LinearParamsType:$W_prepack,
    Torch_FloatType:$Y_scale_i,
    Torch_IntType:$Y_zero_point_i
  );
  let results = (outs
    AnyTorchTensorType:$Y
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult QuantizedLinearOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void QuantizedLinearOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

