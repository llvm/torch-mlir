//===-------------------------------------------------------*- tablegen -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Also available under a BSD-style license. See LICENSE.
//
// Operation summaries and descriptions were systematically derived from public
// API docstrings and are licensed accordingly:
//   https://github.com/pytorch/pytorch/blob/master/LICENSE
//===----------------------------------------------------------------------===//
//
// This file is automatically generated.  Please do not edit.
// Generated via:
// ```
// build_tools/update_torch_ods.sh
// ```
//
//===----------------------------------------------------------------------===//


def Torch_AtenHardtanhOp : Torch_Op<"aten.hardtanh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardtanh : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min_val,
    AnyTorchScalarType:$max_val
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardtanhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenHardtanhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenHardtanh_Op : Torch_Op<"aten.hardtanh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::hardtanh_ : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$min_val,
    AnyTorchScalarType:$max_val
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardtanh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenHardtanh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenEluOp : Torch_Op<"aten.elu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::elu : (Tensor, Scalar, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$alpha,
    AnyTorchScalarType:$scale,
    AnyTorchScalarType:$input_scale
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenEluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenElu_Op : Torch_Op<"aten.elu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::elu_ : (Tensor, Scalar, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$alpha,
    AnyTorchScalarType:$scale,
    AnyTorchScalarType:$input_scale
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenElu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenElu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenReluOp : Torch_Op<"aten.relu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::relu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenReluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRelu_Op : Torch_Op<"aten.relu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::relu_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRelu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRelu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRelu6Op : Torch_Op<"aten.relu6", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::relu6 : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRelu6Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRelu6Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRelu6_Op : Torch_Op<"aten.relu6_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::relu6_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRelu6_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRelu6_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLeakyReluOp : Torch_Op<"aten.leaky_relu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::leaky_relu : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$negative_slope
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeakyReluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeakyReluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLeakyRelu_Op : Torch_Op<"aten.leaky_relu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::leaky_relu_ : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$negative_slope
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeakyRelu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeakyRelu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogOp : Torch_Op<"aten.log", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLogOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog_Op : Torch_Op<"aten.log_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::log_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSeluOp : Torch_Op<"aten.selu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::selu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSeluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSeluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSelu_Op : Torch_Op<"aten.selu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::selu_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSelu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSigmoidOp : Torch_Op<"aten.sigmoid", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sigmoid : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSigmoidOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSigmoidOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSigmoid_Op : Torch_Op<"aten.sigmoid_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sigmoid_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSigmoid_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSigmoid_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSignOp : Torch_Op<"aten.sign", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sign : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSignOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSignOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSign_Op : Torch_Op<"aten.sign_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sign_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSign_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSign_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSinhOp : Torch_Op<"aten.sinh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sinh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSinhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSinhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSinh_Op : Torch_Op<"aten.sinh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sinh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSinh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSinh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSgnOp : Torch_Op<"aten.sgn", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sgn : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSgnOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSgnOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSgn_Op : Torch_Op<"aten.sgn_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sgn_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSgn_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSgn_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardsigmoidOp : Torch_Op<"aten.hardsigmoid", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardsigmoid : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardsigmoidOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardsigmoidOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardsigmoid_Op : Torch_Op<"aten.hardsigmoid_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::hardsigmoid_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardsigmoid_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardsigmoid_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardswishOp : Torch_Op<"aten.hardswish", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardswish : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardswishOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardswishOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenHardswish_Op : Torch_Op<"aten.hardswish_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::hardswish_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardswish_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenHardswish_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenErfOp : Torch_Op<"aten.erf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::erf : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenErfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenErfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenErf_Op : Torch_Op<"aten.erf_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::erf_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenErf_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenErf_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenErfinvOp : Torch_Op<"aten.erfinv", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::erfinv : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenErfinvOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenErfinvOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenErfinv_Op : Torch_Op<"aten.erfinv_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::erfinv_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenErfinv_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenErfinv_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSiluOp : Torch_Op<"aten.silu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::silu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSiluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSiluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSilu_Op : Torch_Op<"aten.silu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::silu_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSilu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSilu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSinOp : Torch_Op<"aten.sin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sin : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSin_Op : Torch_Op<"aten.sin_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sin_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSin_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSin_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAsinOp : Torch_Op<"aten.asin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::asin : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAsinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAsin_Op : Torch_Op<"aten.asin_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::asin_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsin_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAsin_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAsinhOp : Torch_Op<"aten.asinh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::asinh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsinhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAsinhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAsinh_Op : Torch_Op<"aten.asinh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::asinh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsinh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAsinh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenExpOp : Torch_Op<"aten.exp", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::exp : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenExpOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenExp_Op : Torch_Op<"aten.exp_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::exp_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExp_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenExp_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenExpm1Op : Torch_Op<"aten.expm1", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expm1 : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpm1Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenExpm1Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenExpm1_Op : Torch_Op<"aten.expm1_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::expm1_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpm1_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenExpm1_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCosOp : Torch_Op<"aten.cos", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cos : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCos_Op : Torch_Op<"aten.cos_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::cos_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCos_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCos_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCoshOp : Torch_Op<"aten.cosh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cosh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCoshOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCoshOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCosh_Op : Torch_Op<"aten.cosh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::cosh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCosh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCosh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAcosOp : Torch_Op<"aten.acos", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::acos : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAcosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAcosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAcos_Op : Torch_Op<"aten.acos_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::acos_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAcos_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAcos_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAcoshOp : Torch_Op<"aten.acosh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::acosh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAcoshOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAcoshOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAcosh_Op : Torch_Op<"aten.acosh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::acosh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAcosh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAcosh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTanOp : Torch_Op<"aten.tan", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tan : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTanOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTan_Op : Torch_Op<"aten.tan_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::tan_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTan_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTan_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTanhOp : Torch_Op<"aten.tanh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tanh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTanhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTanh_Op : Torch_Op<"aten.tanh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::tanh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTanh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAtanOp : Torch_Op<"aten.atan", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::atan : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAtanOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAtanOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAtan_Op : Torch_Op<"aten.atan_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::atan_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAtan_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAtan_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAtanhOp : Torch_Op<"aten.atanh", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::atanh : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAtanhOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAtanhOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAtanh_Op : Torch_Op<"aten.atanh_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::atanh_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAtanh_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAtanh_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAtan2Op : Torch_Op<"aten.atan2", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::atan2 : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAtan2Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAtan2Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAtan2_Op : Torch_Op<"aten.atan2_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::atan2_ : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAtan2_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAtan2_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNegOp : Torch_Op<"aten.neg", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::neg : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNegOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNegOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNeg_Op : Torch_Op<"aten.neg_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::neg_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeg_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNeg_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBitwiseNotOp : Torch_Op<"aten.bitwise_not", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_not : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseNotOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBitwiseNotOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBitwiseNot_Op : Torch_Op<"aten.bitwise_not_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_not_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseNot_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBitwiseNot_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenDivTensorOp : Torch_Op<"aten.div.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDiv_TensorOp : Torch_Op<"aten.div_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::div_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiv_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDiv_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalOrOp : Torch_Op<"aten.logical_or", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logical_or : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalOrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalOrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalOr_Op : Torch_Op<"aten.logical_or_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::logical_or_ : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalOr_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalOr_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalAndOp : Torch_Op<"aten.logical_and", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logical_and : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalAndOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalAndOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalAnd_Op : Torch_Op<"aten.logical_and_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::logical_and_ : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalAnd_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalAnd_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalXorOp : Torch_Op<"aten.logical_xor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logical_xor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalXorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalXorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalXor_Op : Torch_Op<"aten.logical_xor_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::logical_xor_ : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalXor_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogicalXor_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogicalNotOp : Torch_Op<"aten.logical_not", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logical_not : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalNotOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLogicalNotOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLogicalNot_Op : Torch_Op<"aten.logical_not_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::logical_not_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogicalNot_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLogicalNot_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLerpTensorOp : Torch_Op<"aten.lerp.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lerp.Tensor : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$end,
    AnyTorchTensorType:$weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLerpTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLerpTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLerp_TensorOp : Torch_Op<"aten.lerp_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lerp_.Tensor : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$end,
    Torch_NonValueTensorType:$weight
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLerp_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLerp_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLerpScalarOp : Torch_Op<"aten.lerp.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lerp.Scalar : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$end,
    AnyTorchScalarType:$weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLerpScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLerpScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLerp_ScalarOp : Torch_Op<"aten.lerp_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lerp_.Scalar : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$end,
    AnyTorchScalarType:$weight
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLerp_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLerp_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenGtTensorOp : Torch_Op<"aten.gt.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGt_TensorOp : Torch_Op<"aten.gt_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::gt_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGt_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGt_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGeTensorOp : Torch_Op<"aten.ge.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGe_TensorOp : Torch_Op<"aten.ge_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ge_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGe_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGe_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLtTensorOp : Torch_Op<"aten.lt.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLt_TensorOp : Torch_Op<"aten.lt_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lt_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLt_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLt_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLeTensorOp : Torch_Op<"aten.le.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::le.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLe_TensorOp : Torch_Op<"aten.le_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::le_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLe_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLe_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeTensorOp : Torch_Op<"aten.ne.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNe_TensorOp : Torch_Op<"aten.ne_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ne_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNe_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNe_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDivScalarOp : Torch_Op<"aten.div.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDiv_ScalarOp : Torch_Op<"aten.div_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::div_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiv_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDiv_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFmodScalarOp : Torch_Op<"aten.fmod.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fmod.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFmodScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFmodScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFmod_ScalarOp : Torch_Op<"aten.fmod_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::fmod_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFmod_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFmod_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMaskedFillScalarOp : Torch_Op<"aten.masked_fill.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::masked_fill.Scalar : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedFillScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedFillScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMaskedFill_ScalarOp : Torch_Op<"aten.masked_fill_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::masked_fill_.Scalar : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$mask,
    AnyTorchScalarType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedFill_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedFill_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClampOp : Torch_Op<"aten.clamp", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp : (Tensor, Scalar?, Scalar?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalScalarType:$min,
    AnyTorchOptionalScalarType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenClampOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClamp_Op : Torch_Op<"aten.clamp_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_ : (Tensor, Scalar?, Scalar?) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchOptionalScalarType:$min,
    AnyTorchOptionalScalarType:$max
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClamp_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenClamp_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClampTensorOp : Torch_Op<"aten.clamp.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp.Tensor : (Tensor, Tensor?, Tensor?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalTensorType:$min,
    AnyTorchOptionalTensorType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenClampTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClamp_TensorOp : Torch_Op<"aten.clamp_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_.Tensor : (Tensor, Tensor?, Tensor?) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchOptionalNonValueTensorType:$min,
    AnyTorchOptionalNonValueTensorType:$max
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClamp_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenClamp_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenClampMinOp : Torch_Op<"aten.clamp_min", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp_min : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMin_Op : Torch_Op<"aten.clamp_min_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_min_ : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$min
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMin_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMin_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMinTensorOp : Torch_Op<"aten.clamp_min.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp_min.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$min
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMinTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMinTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMin_TensorOp : Torch_Op<"aten.clamp_min_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_min_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$min
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMin_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMin_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMaxOp : Torch_Op<"aten.clamp_max", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp_max : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMax_Op : Torch_Op<"aten.clamp_max_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_max_ : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$max
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMax_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMax_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMaxTensorOp : Torch_Op<"aten.clamp_max.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clamp_max.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMaxTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMaxTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenClampMax_TensorOp : Torch_Op<"aten.clamp_max_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::clamp_max_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$max
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenClampMax_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenClampMax_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLog2Op : Torch_Op<"aten.log2", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log2 : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog2Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog2Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog2_Op : Torch_Op<"aten.log2_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::log2_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog2_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog2_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog10Op : Torch_Op<"aten.log10", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log10 : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog10Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog10Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog10_Op : Torch_Op<"aten.log10_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::log10_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog10_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog10_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSqrtOp : Torch_Op<"aten.sqrt", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sqrt : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqrtOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqrtOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSqrt_Op : Torch_Op<"aten.sqrt_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sqrt_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqrt_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqrt_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog1pOp : Torch_Op<"aten.log1p", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log1p : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog1pOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog1pOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLog1p_Op : Torch_Op<"aten.log1p_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::log1p_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLog1p_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLog1p_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenLogitOp : Torch_Op<"aten.logit", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logit : (Tensor, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalFloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogitOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogitOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogit_Op : Torch_Op<"aten.logit_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::logit_ : (Tensor, float?) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchOptionalFloatType:$eps
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogit_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLogit_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenRsqrtOp : Torch_Op<"aten.rsqrt", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rsqrt : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRsqrtOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRsqrtOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRsqrt_Op : Torch_Op<"aten.rsqrt_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::rsqrt_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRsqrt_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRsqrt_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAbsOp : Torch_Op<"aten.abs", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::abs : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAbsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAbsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAbs_Op : Torch_Op<"aten.abs_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::abs_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAbs_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAbs_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenReciprocalOp : Torch_Op<"aten.reciprocal", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reciprocal : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReciprocalOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenReciprocalOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenReciprocal_Op : Torch_Op<"aten.reciprocal_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::reciprocal_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReciprocal_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenReciprocal_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBitwiseAndTensorOp : Torch_Op<"aten.bitwise_and.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_and.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseAndTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseAndTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseAnd_TensorOp : Torch_Op<"aten.bitwise_and_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_and_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseAnd_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseAnd_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseAndScalarOp : Torch_Op<"aten.bitwise_and.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_and.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseAndScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseAndScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseAnd_ScalarOp : Torch_Op<"aten.bitwise_and_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_and_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseAnd_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseAnd_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseOrTensorOp : Torch_Op<"aten.bitwise_or.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_or.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseOrTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseOrTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseOr_TensorOp : Torch_Op<"aten.bitwise_or_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_or_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseOr_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseOr_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseXorTensorOp : Torch_Op<"aten.bitwise_xor.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_xor.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseXorTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseXorTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseXor_TensorOp : Torch_Op<"aten.bitwise_xor_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_xor_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseXor_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseXor_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseLeftShiftTensorOp : Torch_Op<"aten.bitwise_left_shift.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_left_shift.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseLeftShiftTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseLeftShiftTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseLeftShift_TensorOp : Torch_Op<"aten.bitwise_left_shift_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_left_shift_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseLeftShift_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseLeftShift_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseRightShiftTensorOp : Torch_Op<"aten.bitwise_right_shift.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bitwise_right_shift.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseRightShiftTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseRightShiftTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBitwiseRightShift_TensorOp : Torch_Op<"aten.bitwise_right_shift_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bitwise_right_shift_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBitwiseRightShift_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBitwiseRightShift_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenThresholdOp : Torch_Op<"aten.threshold", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::threshold : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$threshold,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenThresholdOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenThresholdOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenThreshold_Op : Torch_Op<"aten.threshold_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::threshold_ : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$threshold,
    AnyTorchScalarType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenThreshold_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenThreshold_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSquareOp : Torch_Op<"aten.square", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::square : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSquareOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSquareOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSquare_Op : Torch_Op<"aten.square_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::square_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSquare_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSquare_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenZeroOp : Torch_Op<"aten.zero", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::zero : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZeroOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenZeroOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenZero_Op : Torch_Op<"aten.zero_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::zero_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZero_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenZero_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFillScalarOp : Torch_Op<"aten.fill.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fill.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFillScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFillScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFill_ScalarOp : Torch_Op<"aten.fill_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::fill_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFill_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFill_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFillTensorOp : Torch_Op<"aten.fill.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fill.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFillTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFillTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFill_TensorOp : Torch_Op<"aten.fill_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::fill_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFill_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFill_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUnsqueezeOp : Torch_Op<"aten.unsqueeze", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unsqueeze : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnsqueezeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnsqueezeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenUnsqueeze_Op : Torch_Op<"aten.unsqueeze_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::unsqueeze_ : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnsqueeze_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnsqueeze_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenDivTensorModeOp : Torch_Op<"aten.div.Tensor_mode", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.Tensor_mode : (Tensor, Tensor, str?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchOptionalStringType:$rounding_mode
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivTensorModeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDivTensorModeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenDiv_TensorModeOp : Torch_Op<"aten.div_.Tensor_mode", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::div_.Tensor_mode : (Tensor, Tensor, str?) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other,
    AnyTorchOptionalStringType:$rounding_mode
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiv_TensorModeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDiv_TensorModeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMulTensorOp : Torch_Op<"aten.mul.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_AtenMul_TensorOp : Torch_Op<"aten.mul_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::mul_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMul_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMul_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddTensorOp : Torch_Op<"aten.add.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAddTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_AtenAdd_TensorOp : Torch_Op<"aten.add_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::add_.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdd_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAdd_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSubTensorOp : Torch_Op<"aten.sub.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSubTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_AtenSub_TensorOp : Torch_Op<"aten.sub_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sub_.Tensor : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSub_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSub_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAddScalarOp : Torch_Op<"aten.add.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAddScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenAdd_ScalarOp : Torch_Op<"aten.add_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::add_.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdd_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAdd_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSubScalarOp : Torch_Op<"aten.sub.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSubScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenSub_ScalarOp : Torch_Op<"aten.sub_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sub_.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSub_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSub_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMulScalarOp : Torch_Op<"aten.mul.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenMul_ScalarOp : Torch_Op<"aten.mul_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::mul_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMul_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMul_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEqTensorOp : Torch_Op<"aten.eq.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEq_TensorOp : Torch_Op<"aten.eq_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::eq_.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEq_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEq_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLeScalarOp : Torch_Op<"aten.le.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::le.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLe_ScalarOp : Torch_Op<"aten.le_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::le_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLe_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLe_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLtScalarOp : Torch_Op<"aten.lt.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLt_ScalarOp : Torch_Op<"aten.lt_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::lt_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLt_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLt_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGtScalarOp : Torch_Op<"aten.gt.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGt_ScalarOp : Torch_Op<"aten.gt_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::gt_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGt_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGt_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGeScalarOp : Torch_Op<"aten.ge.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGe_ScalarOp : Torch_Op<"aten.ge_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ge_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGe_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGe_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEqScalarOp : Torch_Op<"aten.eq.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEq_ScalarOp : Torch_Op<"aten.eq_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::eq_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEq_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEq_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeScalarOp : Torch_Op<"aten.ne.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNe_ScalarOp : Torch_Op<"aten.ne_.Scalar", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ne_.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNe_ScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNe_ScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenFloorOp : Torch_Op<"aten.floor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floor : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFloor_Op : Torch_Op<"aten.floor_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::floor_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloor_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloor_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCeilOp : Torch_Op<"aten.ceil", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ceil : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeilOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeilOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenCeil_Op : Torch_Op<"aten.ceil_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::ceil_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeil_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeil_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenRoundOp : Torch_Op<"aten.round", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::round : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRoundOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRoundOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenRound_Op : Torch_Op<"aten.round_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::round_ : (Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRound_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRound_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenMaskedFillTensorOp : Torch_Op<"aten.masked_fill.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::masked_fill.Tensor : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask,
    AnyTorchTensorType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedFillTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedFillTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenMaskedFill_TensorOp : Torch_Op<"aten.masked_fill_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::masked_fill_.Tensor : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$mask,
    Torch_NonValueTensorType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedFill_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedFill_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAddcmulOp : Torch_Op<"aten.addcmul", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::addcmul : (Tensor, Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$tensor1,
    AnyTorchTensorType:$tensor2,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddcmulOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAddcmulOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenAddcmul_Op : Torch_Op<"aten.addcmul_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::addcmul_ : (Tensor, Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$tensor1,
    Torch_NonValueTensorType:$tensor2,
    AnyTorchScalarType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddcmul_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAddcmul_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenAddcdivOp : Torch_Op<"aten.addcdiv", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::addcdiv : (Tensor, Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$tensor1,
    AnyTorchTensorType:$tensor2,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddcdivOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAddcdivOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenAddcdiv_Op : Torch_Op<"aten.addcdiv_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::addcdiv_ : (Tensor, Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$tensor1,
    Torch_NonValueTensorType:$tensor2,
    AnyTorchScalarType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddcdiv_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAddcdiv_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenFakeQuantizePerTensorAffineOp : Torch_Op<"aten.fake_quantize_per_tensor_affine", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fake_quantize_per_tensor_affine : (Tensor, float, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$scale,
    Torch_IntType:$zero_point,
    Torch_IntType:$quant_min,
    Torch_IntType:$quant_max
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFakeQuantizePerTensorAffineOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenFakeQuantizePerTensorAffineOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenMaximumOp : Torch_Op<"aten.maximum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::maximum : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaximumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMaximumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMinimumOp : Torch_Op<"aten.minimum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::minimum : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMinimumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMinimumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMishOp : Torch_Op<"aten.mish", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mish : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMishOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenMishOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenXlogyTensorOp : Torch_Op<"aten.xlogy.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::xlogy.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenXlogyTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenXlogyTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenRsubScalarOp : Torch_Op<"aten.rsub.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rsub.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRsubScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenRsubScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenGeluOp : Torch_Op<"aten.gelu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gelu : (Tensor, str) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_StringType:$approximate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPowTensorScalarOp : Torch_Op<"aten.pow.Tensor_Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pow.Tensor_Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$exponent
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPowTensorScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPowTensorScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPowTensorTensorOp : Torch_Op<"aten.pow.Tensor_Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pow.Tensor_Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$exponent
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPowTensorTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPowTensorTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPowScalarOp : Torch_Op<"aten.pow.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pow.Scalar : (Scalar, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$self,
    AnyTorchTensorType:$exponent
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPowScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPowScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenThresholdBackwardOp : Torch_Op<"aten.threshold_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::threshold_backward : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$threshold
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenThresholdBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenThresholdBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenFloorDivideOp : Torch_Op<"aten.floor_divide", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floor_divide : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloorDivideOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFloorDivideOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSoftplusOp : Torch_Op<"aten.softplus", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::softplus : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$threshold
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSoftplusOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSoftplusOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenPreluOp : Torch_Op<"aten.prelu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::prelu : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPreluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPreluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenRealOp : Torch_Op<"aten.real", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::real : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRealOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenRealOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenImagOp : Torch_Op<"aten.imag", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::imag : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenImagOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenImagOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenViewAsComplexOp : Torch_Op<"aten.view_as_complex", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view_as_complex : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewAsComplexOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenViewAsComplexOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenViewAsRealOp : Torch_Op<"aten.view_as_real", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view_as_real : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewAsRealOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenViewAsRealOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIscloseOp : Torch_Op<"aten.isclose", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::isclose : (Tensor, Tensor, float, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    Torch_FloatType:$rtol,
    Torch_FloatType:$atol,
    Torch_BoolType:$equal_nan
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIscloseOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenIscloseOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenGluOp : Torch_Op<"aten.glu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::glu : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGluOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGluOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUnbindCopyIntOp : Torch_Op<"aten.unbind_copy.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unbind_copy.int : (Tensor, int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnbindCopyIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnbindCopyIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSplitCopyTensorOp : Torch_Op<"aten.split_copy.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::split_copy.Tensor : (Tensor, int, int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$split_size,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSplitCopyTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSplitCopyTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSplitWithSizesCopyOp : Torch_Op<"aten.split_with_sizes_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::split_with_sizes_copy : (Tensor, int[], int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$split_sizes,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSplitWithSizesCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSplitWithSizesCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenUniformOp : Torch_Op<"aten.uniform", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::uniform : (Tensor, float, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$from,
    Torch_FloatType:$to,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUniformOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenUniformOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenUniform_Op : Torch_Op<"aten.uniform_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::uniform_ : (Tensor, float, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_FloatType:$from,
    Torch_FloatType:$to,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUniform_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenUniform_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenRandLikeOp : Torch_Op<"aten.rand_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rand_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenRandLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenRandOp : Torch_Op<"aten.rand", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::rand : (int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenRandOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenBernoulliOp : Torch_Op<"aten.bernoulli", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bernoulli : (Tensor, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulliOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBernoulliOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBernoulli_FloatOp : Torch_Op<"aten.bernoulli_.float", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bernoulli_.float : (Tensor, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$p,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulli_FloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBernoulli_FloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenBernoulliPOp : Torch_Op<"aten.bernoulli.p", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bernoulli.p : (Tensor, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$p,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulliPOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBernoulliPOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenExponentialOp : Torch_Op<"aten.exponential", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::exponential : (Tensor, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$lambd,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExponentialOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenExponentialOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMultinomialOp : Torch_Op<"aten.multinomial", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::multinomial : (Tensor, int, bool, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$num_samples,
    Torch_BoolType:$replacement,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMultinomialOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenMultinomialOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenRandintLowOp : Torch_Op<"aten.randint.low", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::randint.low : (int, int, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    Torch_IntType:$low,
    Torch_IntType:$high,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandintLowOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenRandintLowOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenRandintOp : Torch_Op<"aten.randint", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::randint : (int, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    Torch_IntType:$high,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandintOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenRandintOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenBernoulliTensorOp : Torch_Op<"aten.bernoulli.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bernoulli.Tensor : (Tensor, Tensor, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$p,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulliTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBernoulliTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenBernoulli_TensorOp : Torch_Op<"aten.bernoulli_.Tensor", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::bernoulli_.Tensor : (Tensor, Tensor, Generator?) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$p,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBernoulli_TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBernoulli_TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenRandnOp : Torch_Op<"aten.randn", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::randn : (int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandnOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenRandnOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenRandnGeneratorOp : Torch_Op<"aten.randn.generator", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::randn.generator : (int[], Generator?, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalGeneratorType:$generator,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandnGeneratorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenRandnGeneratorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenRandnLikeOp : Torch_Op<"aten.randn_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::randn_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandnLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenRandnLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenRandomOp : Torch_Op<"aten.random", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::random : (Tensor, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandomOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRandomOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenRandomFromOp : Torch_Op<"aten.random.from", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::random.from : (Tensor, int, int?, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$from,
    AnyTorchOptionalIntType:$to,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRandomFromOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenRandomFromOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenTriuOp : Torch_Op<"aten.triu", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::triu : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$diagonal
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTriuOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTriuOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTriu_Op : Torch_Op<"aten.triu_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::triu_ : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$diagonal
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTriu_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTriu_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTrilOp : Torch_Op<"aten.tril", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tril : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$diagonal
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTrilOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTrilOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTril_Op : Torch_Op<"aten.tril_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::tril_ : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$diagonal
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTril_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTril_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenIndexPutOp : Torch_Op<"aten.index_put", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index_put : (Tensor, Tensor?[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIndexPut_Op : Torch_Op<"aten.index_put_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::index_put_ : (Tensor, Tensor?[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchListOfOptionalNonValueTensorType:$indices,
    Torch_NonValueTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPut_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPut_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIndexPutHackedTwinOp : Torch_Op<"aten.index_put.hacked_twin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index_put.hacked_twin : (Tensor, Tensor[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPutHackedTwinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPutHackedTwinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIndexPut_HackedTwinOp : Torch_Op<"aten.index_put_.hacked_twin", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::index_put_.hacked_twin : (Tensor, Tensor[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchListOfNonValueTensorType:$indices,
    Torch_NonValueTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexPut_HackedTwinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenIndexPut_HackedTwinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_Aten_UnsafeIndexPutHackedTwinOp : Torch_Op<"aten._unsafe_index_put.hacked_twin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_unsafe_index_put.hacked_twin : (Tensor, Tensor[], Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_UnsafeIndexPutHackedTwinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void Aten_UnsafeIndexPutHackedTwinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenLinearOp : Torch_Op<"aten.linear", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linear : (Tensor, Tensor, Tensor?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinearOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLinearOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMmOp : Torch_Op<"aten.mm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mm : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mat2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddmmOp : Torch_Op<"aten.addmm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::addmm : (Tensor, Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mat1,
    AnyTorchTensorType:$mat2,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddmmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenAddmmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenMatmulOp : Torch_Op<"aten.matmul", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::matmul : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMatmulOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMatmulOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenMvOp : Torch_Op<"aten.mv", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mv : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$vec
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMvOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMvOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCosineSimilarityOp : Torch_Op<"aten.cosine_similarity", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cosine_similarity : (Tensor, Tensor, int, float) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$x1,
    AnyTorchTensorType:$x2,
    Torch_IntType:$dim,
    Torch_FloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCosineSimilarityOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenCosineSimilarityOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenConv3dOp : Torch_Op<"aten.conv3d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv3d : (Tensor, Tensor, Tensor?, int[], int[], int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConv3dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenConv3dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenConv2dOp : Torch_Op<"aten.conv2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv2d : (Tensor, Tensor, Tensor?, int[], int[], int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConv2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenConv2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenConv1dOp : Torch_Op<"aten.conv1d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv1d : (Tensor, Tensor, Tensor?, int[], int[], int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConv1dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenConv1dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenConvTranspose1dOp : Torch_Op<"aten.conv_transpose1d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv_transpose1d : (Tensor, Tensor, Tensor?, int[], int[], int[], int, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    AnyTorchListOfTorchIntType:$dilation
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvTranspose1dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenConvTranspose1dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenConvTranspose2dInputOp : Torch_Op<"aten.conv_transpose2d.input", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv_transpose2d.input : (Tensor, Tensor, Tensor?, int[], int[], int[], int, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    AnyTorchListOfTorchIntType:$dilation
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvTranspose2dInputOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenConvTranspose2dInputOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenConvTranspose3dInputOp : Torch_Op<"aten.conv_transpose3d.input", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv_transpose3d.input : (Tensor, Tensor, Tensor?, int[], int[], int[], int, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    AnyTorchListOfTorchIntType:$dilation
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvTranspose3dInputOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenConvTranspose3dInputOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenConvTbcOp : Torch_Op<"aten.conv_tbc", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv_tbc : (Tensor, Tensor, Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$weight,
    AnyTorchTensorType:$bias,
    Torch_IntType:$pad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvTbcOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenConvTbcOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenConvTbcBackwardOp : Torch_Op<"aten.conv_tbc_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::conv_tbc_backward : (Tensor, Tensor, Tensor, Tensor, int) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchTensorType:$bias,
    Torch_IntType:$pad
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvTbcBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 3);
    }
    void AtenConvTbcBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 3);
    }
  }];
}

def Torch_AtenConvolutionOp : Torch_Op<"aten.convolution", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::convolution : (Tensor, Tensor, Tensor?, int[], int[], int[], bool, int[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvolutionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 1);
    }
    void AtenConvolutionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 1);
    }
  }];
}

def Torch_Aten_ConvolutionOp : Torch_Op<"aten._convolution", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_convolution : (Tensor, Tensor, Tensor?, int[], int[], int[], bool, int[], int, bool, bool, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    Torch_BoolType:$benchmark,
    Torch_BoolType:$deterministic,
    Torch_BoolType:$cudnn_enabled,
    Torch_BoolType:$allow_tf32
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ConvolutionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 13, 1);
    }
    void Aten_ConvolutionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 13, 1);
    }
  }];
}

def Torch_Aten_ConvolutionDeprecatedOp : Torch_Op<"aten._convolution.deprecated", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_convolution.deprecated : (Tensor, Tensor, Tensor?, int[], int[], int[], bool, int[], int, bool, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    Torch_BoolType:$benchmark,
    Torch_BoolType:$deterministic,
    Torch_BoolType:$cudnn_enabled
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ConvolutionDeprecatedOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 12, 1);
    }
    void Aten_ConvolutionDeprecatedOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 12, 1);
    }
  }];
}

def Torch_AtenRollOp : Torch_Op<"aten.roll", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::roll : (Tensor, int[], int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$shifts,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRollOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenRollOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenConvolutionBackwardOp : Torch_Op<"aten.convolution_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::convolution_backward : (Tensor, Tensor, Tensor, int[]?, int[], int[], int[], bool, int[], int, bool[]) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$weight,
    AnyTorchOptionalListOfTorchIntType:$bias_sizes,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$transposed,
    AnyTorchListOfTorchIntType:$output_padding,
    Torch_IntType:$groups,
    AnyTorchListOfTorchBoolType:$output_mask
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConvolutionBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 11, 3);
    }
    void AtenConvolutionBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 11, 3);
    }
  }];
}

def Torch_AtenFlipOp : Torch_Op<"aten.flip", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::flip : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFlipOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFlipOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNativeBatchNormOp : Torch_Op<"aten.native_batch_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_batch_norm : (Tensor, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, float) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    Torch_BoolType:$training,
    Torch_FloatType:$momentum,
    Torch_FloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeBatchNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 3);
    }
    void AtenNativeBatchNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 3);
    }
  }];
}

def Torch_AtenBatchNormOp : Torch_Op<"aten.batch_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::batch_norm : (Tensor, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    Torch_BoolType:$training,
    Torch_FloatType:$momentum,
    Torch_FloatType:$eps,
    Torch_BoolType:$cudnn_enabled
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBatchNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 1);
    }
    void AtenBatchNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 1);
    }
  }];
}

def Torch_AtenInstanceNormOp : Torch_Op<"aten.instance_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::instance_norm : (Tensor, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    Torch_BoolType:$use_input_stats,
    Torch_FloatType:$momentum,
    Torch_FloatType:$eps,
    Torch_BoolType:$cudnn_enabled
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenInstanceNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 1);
    }
    void AtenInstanceNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 1);
    }
  }];
}

def Torch_AtenNativeGroupNormOp : Torch_Op<"aten.native_group_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_group_norm : (Tensor, Tensor?, Tensor?, int, int, int, int, float) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    Torch_IntType:$N,
    Torch_IntType:$C,
    Torch_IntType:$HxW,
    Torch_IntType:$group,
    Torch_FloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeGroupNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 3);
    }
    void AtenNativeGroupNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 3);
    }
  }];
}

def Torch_AtenGroupNormOp : Torch_Op<"aten.group_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::group_norm : (Tensor, int, Tensor?, Tensor?, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    Torch_IntType:$num_groups,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    Torch_FloatType:$eps,
    Torch_BoolType:$cudnn_enabled
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGroupNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenGroupNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenLayerNormOp : Torch_Op<"aten.layer_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::layer_norm : (Tensor, int[], Tensor?, Tensor?, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchListOfTorchIntType:$normalized_shape,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    Torch_FloatType:$eps,
    Torch_BoolType:$cudnn_enable
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLayerNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenLayerNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenNormScalarOp : Torch_Op<"aten.norm.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::norm.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$p
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNormScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNormScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasVerifier = 1;
}

def Torch_AtenNormScalarOptDimOp : Torch_Op<"aten.norm.ScalarOpt_dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::norm.ScalarOpt_dim : (Tensor, Scalar?, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalScalarType:$p,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNormScalarOptDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenNormScalarOptDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenNormalFunctionalOp : Torch_Op<"aten.normal_functional", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::normal_functional : (Tensor, float, float, Generator?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$mean,
    Torch_FloatType:$std,
    AnyTorchOptionalGeneratorType:$generator
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNormalFunctionalOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenNormalFunctionalOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenNativeLayerNormOp : Torch_Op<"aten.native_layer_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_layer_norm : (Tensor, int[], Tensor?, Tensor?, float) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchListOfTorchIntType:$normalized_shape,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    Torch_FloatType:$eps
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeLayerNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 3);
    }
    void AtenNativeLayerNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 3);
    }
  }];
}

def Torch_AtenMaxPool2dOp : Torch_Op<"aten.max_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool2d : (Tensor, int[], int[], int[], int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenMaxPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenMaxPool2dWithIndicesOp : Torch_Op<"aten.max_pool2d_with_indices", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool2d_with_indices : (Tensor, int[], int[], int[], int[], bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool2dWithIndicesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 2);
    }
    void AtenMaxPool2dWithIndicesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 2);
    }
  }];
}

def Torch_AtenMaxPool2dWithIndicesBackwardOp : Torch_Op<"aten.max_pool2d_with_indices_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool2d_with_indices_backward : (Tensor, Tensor, int[], int[], int[], int[], bool, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode,
    AnyTorchTensorType:$indices
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool2dWithIndicesBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenMaxPool2dWithIndicesBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenMaxPool3dOp : Torch_Op<"aten.max_pool3d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool3d : (Tensor, int[], int[], int[], int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool3dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenMaxPool3dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenMaxPool3dWithIndicesOp : Torch_Op<"aten.max_pool3d_with_indices", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool3d_with_indices : (Tensor, int[], int[], int[], int[], bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool3dWithIndicesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 2);
    }
    void AtenMaxPool3dWithIndicesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 2);
    }
  }];
}

def Torch_AtenMaxPool3dWithIndicesBackwardOp : Torch_Op<"aten.max_pool3d_with_indices_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max_pool3d_with_indices_backward : (Tensor, Tensor, int[], int[], int[], int[], bool, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$dilation,
    Torch_BoolType:$ceil_mode,
    AnyTorchTensorType:$indices
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxPool3dWithIndicesBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenMaxPool3dWithIndicesBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenAvgPool1dOp : Torch_Op<"aten.avg_pool1d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::avg_pool1d : (Tensor, int[], int[], int[], bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    Torch_BoolType:$ceil_mode,
    Torch_BoolType:$count_include_pad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAvgPool1dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenAvgPool1dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenAvgPool2dOp : Torch_Op<"aten.avg_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::avg_pool2d : (Tensor, int[], int[], int[], bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    Torch_BoolType:$ceil_mode,
    Torch_BoolType:$count_include_pad,
    AnyTorchOptionalIntType:$divisor_override
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAvgPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenAvgPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenAvgPool2dBackwardOp : Torch_Op<"aten.avg_pool2d_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::avg_pool2d_backward : (Tensor, Tensor, int[], int[], int[], bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    Torch_BoolType:$ceil_mode,
    Torch_BoolType:$count_include_pad,
    AnyTorchOptionalIntType:$divisor_override
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAvgPool2dBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenAvgPool2dBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenAvgPool3dOp : Torch_Op<"aten.avg_pool3d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::avg_pool3d : (Tensor, int[], int[], int[], bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    Torch_BoolType:$ceil_mode,
    Torch_BoolType:$count_include_pad,
    AnyTorchOptionalIntType:$divisor_override
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAvgPool3dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenAvgPool3dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenAvgPool3dBackwardOp : Torch_Op<"aten.avg_pool3d_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::avg_pool3d_backward : (Tensor, Tensor, int[], int[], int[], bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchListOfTorchIntType:$padding,
    Torch_BoolType:$ceil_mode,
    Torch_BoolType:$count_include_pad,
    AnyTorchOptionalIntType:$divisor_override
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAvgPool3dBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenAvgPool3dBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
}

def Torch_AtenSoftmaxIntOp : Torch_Op<"aten.softmax.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::softmax.int : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSoftmaxIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSoftmaxIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLogSoftmaxIntOp : Torch_Op<"aten.log_softmax.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log_softmax.int : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogSoftmaxIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLogSoftmaxIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_LogSoftmaxOp : Torch_Op<"aten._log_softmax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_log_softmax : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$half_to_float
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_LogSoftmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_LogSoftmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenScatterSrcOp : Torch_Op<"aten.scatter.src", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scatter.src : (Tensor, int, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    AnyTorchTensorType:$src
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterSrcOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatterSrcOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatter_SrcOp : Torch_Op<"aten.scatter_.src", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::scatter_.src : (Tensor, int, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$dim,
    Torch_NonValueTensorType:$index,
    Torch_NonValueTensorType:$src
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatter_SrcOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatter_SrcOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatterValueOp : Torch_Op<"aten.scatter.value", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scatter.value : (Tensor, int, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterValueOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatterValueOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatter_ValueOp : Torch_Op<"aten.scatter_.value", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::scatter_.value : (Tensor, int, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$dim,
    Torch_NonValueTensorType:$index,
    AnyTorchScalarType:$value
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatter_ValueOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatter_ValueOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenMaskedScatterOp : Torch_Op<"aten.masked_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::masked_scatter : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask,
    AnyTorchTensorType:$source
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMaskedScatter_Op : Torch_Op<"aten.masked_scatter_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::masked_scatter_ : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$mask,
    Torch_NonValueTensorType:$source
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedScatter_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMaskedScatter_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAdaptiveAvgPool1dOp : Torch_Op<"aten.adaptive_avg_pool1d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_avg_pool1d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveAvgPool1dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAdaptiveAvgPool1dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAdaptiveAvgPool2dOp : Torch_Op<"aten.adaptive_avg_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_avg_pool2d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveAvgPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAdaptiveAvgPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_AdaptiveAvgPool2dOp : Torch_Op<"aten._adaptive_avg_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_adaptive_avg_pool2d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_AdaptiveAvgPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_AdaptiveAvgPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_AdaptiveAvgPool2dBackwardOp : Torch_Op<"aten._adaptive_avg_pool2d_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_adaptive_avg_pool2d_backward : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_AdaptiveAvgPool2dBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_AdaptiveAvgPool2dBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAdaptiveAvgPool3dOp : Torch_Op<"aten.adaptive_avg_pool3d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_avg_pool3d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveAvgPool3dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAdaptiveAvgPool3dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_AdaptiveAvgPool3dOp : Torch_Op<"aten._adaptive_avg_pool3d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_adaptive_avg_pool3d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_AdaptiveAvgPool3dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_AdaptiveAvgPool3dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_AdaptiveAvgPool3dBackwardOp : Torch_Op<"aten._adaptive_avg_pool3d_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_adaptive_avg_pool3d_backward : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_AdaptiveAvgPool3dBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_AdaptiveAvgPool3dBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAdaptiveMaxPool1dOp : Torch_Op<"aten.adaptive_max_pool1d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_max_pool1d : (Tensor, int[]) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveMaxPool1dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 2);
    }
    void AtenAdaptiveMaxPool1dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 2);
    }
  }];
}

def Torch_AtenAdaptiveMaxPool2dOp : Torch_Op<"aten.adaptive_max_pool2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_max_pool2d : (Tensor, int[]) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveMaxPool2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 2);
    }
    void AtenAdaptiveMaxPool2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 2);
    }
  }];
}

def Torch_AtenAdaptiveMaxPool3dOp : Torch_Op<"aten.adaptive_max_pool3d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::adaptive_max_pool3d : (Tensor, int[]) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAdaptiveMaxPool3dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 2);
    }
    void AtenAdaptiveMaxPool3dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 2);
    }
  }];
}

def Torch_AtenTopkOp : Torch_Op<"aten.topk", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::topk : (Tensor, int, int, bool, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$k,
    Torch_IntType:$dim,
    Torch_BoolType:$largest,
    Torch_BoolType:$sorted
  );
  let results = (outs
    AnyTorchTensorType:$values,
    AnyTorchTensorType:$indices
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTopkOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 2);
    }
    void AtenTopkOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 2);
    }
  }];
}

def Torch_AtenTransposeIntOp : Torch_Op<"aten.transpose.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::transpose.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim0,
    Torch_IntType:$dim1
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTransposeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenTransposeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenPixelShuffleOp : Torch_Op<"aten.pixel_shuffle", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pixel_shuffle : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$upscale_factor
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPixelShuffleOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPixelShuffleOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPermuteOp : Torch_Op<"aten.permute", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::permute : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPermuteOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPermuteOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasVerifier = 1;
}

def Torch_AtenMovedimIntOp : Torch_Op<"aten.movedim.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::movedim.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$source,
    Torch_IntType:$destination
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMovedimIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMovedimIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenBmmOp : Torch_Op<"aten.bmm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bmm : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mat2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBmmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBmmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCumsumOp : Torch_Op<"aten.cumsum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cumsum : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCumsumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenCumsumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenCumprodOp : Torch_Op<"aten.cumprod", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cumprod : (Tensor, int, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCumprodOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenCumprodOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenFloorDivideScalarOp : Torch_Op<"aten.floor_divide.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floor_divide.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloorDivideScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFloorDivideScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenLogsumexpOp : Torch_Op<"aten.logsumexp", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::logsumexp : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogsumexpOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLogsumexpOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMeanDimOp : Torch_Op<"aten.mean.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mean.dim : (Tensor, int[]?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMeanDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenMeanDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_Aten__And__TensorOp : Torch_Op<"aten.__and__.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__and__.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__And__TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__And__TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten__Or__TensorOp : Torch_Op<"aten.__or__.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__or__.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Or__TensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Or__TensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_Aten_SoftmaxOp : Torch_Op<"aten._softmax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_softmax : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$half_to_float
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SoftmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_SoftmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMeanOp : Torch_Op<"aten.mean", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mean : (Tensor, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMeanOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMeanOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenStdOp : Torch_Op<"aten.std", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::std : (Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_BoolType:$unbiased
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStdOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenStdOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenStdDimOp : Torch_Op<"aten.std.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::std.dim : (Tensor, int[]?, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$unbiased,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStdDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenStdDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenStdCorrectionOp : Torch_Op<"aten.std.correction", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::std.correction : (Tensor, int[]?, Scalar?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    AnyTorchOptionalScalarType:$correction,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStdCorrectionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenStdCorrectionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenVarOp : Torch_Op<"aten.var", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var : (Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_BoolType:$unbiased
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenVarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenVarDimOp : Torch_Op<"aten.var.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var.dim : (Tensor, int[]?, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$unbiased,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenVarDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenVarCorrectionOp : Torch_Op<"aten.var.correction", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var.correction : (Tensor, int[]?, Scalar?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    AnyTorchOptionalScalarType:$correction,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarCorrectionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenVarCorrectionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenVarMeanCorrectionOp : Torch_Op<"aten.var_mean.correction", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var_mean.correction : (Tensor, int[]?, Scalar?, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    AnyTorchOptionalScalarType:$correction,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarMeanCorrectionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 2);
    }
    void AtenVarMeanCorrectionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 2);
    }
  }];
}

def Torch_AtenVarMeanOp : Torch_Op<"aten.var_mean", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var_mean : (Tensor, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_BoolType:$unbiased
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarMeanOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 2);
    }
    void AtenVarMeanOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 2);
    }
  }];
}

def Torch_AtenVarMeanDimOp : Torch_Op<"aten.var_mean.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::var_mean.dim : (Tensor, int[]?, bool, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$unbiased,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenVarMeanDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 2);
    }
    void AtenVarMeanDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 2);
    }
  }];
}

def Torch_AtenNllLoss2dForwardOp : Torch_Op<"aten.nll_loss2d_forward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nll_loss2d_forward : (Tensor, Tensor, Tensor?, int, int) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index
  );
  let results = (outs
    AnyTorchTensorType:$output,
    AnyTorchTensorType:$total_weight
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNllLoss2dForwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 2);
    }
    void AtenNllLoss2dForwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 2);
    }
  }];
}

def Torch_AtenNllLoss2dBackwardOp : Torch_Op<"aten.nll_loss2d_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nll_loss2d_backward : (Tensor, Tensor, Tensor, Tensor?, int, int, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index,
    AnyTorchTensorType:$total_weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNllLoss2dBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenNllLoss2dBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenNllLossForwardOp : Torch_Op<"aten.nll_loss_forward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nll_loss_forward : (Tensor, Tensor, Tensor?, int, int) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index
  );
  let results = (outs
    AnyTorchTensorType:$output,
    AnyTorchTensorType:$total_weight
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNllLossForwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 2);
    }
    void AtenNllLossForwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 2);
    }
  }];
}

def Torch_AtenNllLossBackwardOp : Torch_Op<"aten.nll_loss_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nll_loss_backward : (Tensor, Tensor, Tensor, Tensor?, int, int, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index,
    AnyTorchTensorType:$total_weight
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNllLossBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenNllLossBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenBincountOp : Torch_Op<"aten.bincount", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bincount : (Tensor, Tensor?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalTensorType:$weights,
    Torch_IntType:$minlength
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBincountOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenBincountOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenLinalgVectorNormOp : Torch_Op<"aten.linalg_vector_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linalg_vector_norm : (Tensor, Scalar, int[]?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$ord,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinalgVectorNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenLinalgVectorNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenLinalgNormOp : Torch_Op<"aten.linalg_norm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linalg_norm : (Tensor, Scalar?, int[]?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalScalarType:$ord,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinalgNormOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenLinalgNormOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenLinalgQrOp : Torch_Op<"aten.linalg_qr", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linalg_qr : (Tensor, str) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$A,
    Torch_StringType:$mode
  );
  let results = (outs
    AnyTorchTensorType:$Q,
    AnyTorchTensorType:$R
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinalgQrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 2);
    }
    void AtenLinalgQrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 2);
    }
  }];
}

def Torch_AtenFrobeniusNormDimOp : Torch_Op<"aten.frobenius_norm.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::frobenius_norm.dim : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFrobeniusNormDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenFrobeniusNormDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMseLossOp : Torch_Op<"aten.mse_loss", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mse_loss : (Tensor, Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    Torch_IntType:$reduction
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMseLossOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenMseLossOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMseLossBackwardOp : Torch_Op<"aten.mse_loss_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mse_loss_backward : (Tensor, Tensor, Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    Torch_IntType:$reduction
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMseLossBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenMseLossBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenUpsampleNearest2dBackwardOp : Torch_Op<"aten.upsample_nearest2d_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::upsample_nearest2d_backward : (Tensor, int[], int[], float?, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchListOfTorchIntType:$output_size,
    AnyTorchListOfTorchIntType:$input_size,
    AnyTorchOptionalFloatType:$scales_h,
    AnyTorchOptionalFloatType:$scales_w
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUpsampleNearest2dBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenUpsampleNearest2dBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenCrossEntropyLossOp : Torch_Op<"aten.cross_entropy_loss", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cross_entropy_loss : (Tensor, Tensor, Tensor?, int, int, float) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction,
    Torch_IntType:$ignore_index,
    Torch_FloatType:$label_smoothing
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCrossEntropyLossOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenCrossEntropyLossOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenNonzeroOp : Torch_Op<"aten.nonzero", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nonzero : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNonzeroOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNonzeroOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNonzeroNumpyOp : Torch_Op<"aten.nonzero_numpy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nonzero_numpy : (Tensor) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNonzeroNumpyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNonzeroNumpyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNonzeroStaticOp : Torch_Op<"aten.nonzero_static", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nonzero_static : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$size,
    Torch_IntType:$fill_value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNonzeroStaticOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenNonzeroStaticOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenBinaryCrossEntropyOp : Torch_Op<"aten.binary_cross_entropy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::binary_cross_entropy : (Tensor, Tensor, Tensor?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBinaryCrossEntropyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenBinaryCrossEntropyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenBinaryCrossEntropyBackwardOp : Torch_Op<"aten.binary_cross_entropy_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::binary_cross_entropy_backward : (Tensor, Tensor, Tensor, Tensor?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$target,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$reduction
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBinaryCrossEntropyBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenBinaryCrossEntropyBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenLogSigmoidForwardOp : Torch_Op<"aten.log_sigmoid_forward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log_sigmoid_forward : (Tensor) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$output,
    AnyTorchTensorType:$buffer
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogSigmoidForwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 2);
    }
    void AtenLogSigmoidForwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 2);
    }
  }];
}

def Torch_AtenLogSigmoidBackwardOp : Torch_Op<"aten.log_sigmoid_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log_sigmoid_backward : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$buffer
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogSigmoidBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLogSigmoidBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSigmoidBackwardOp : Torch_Op<"aten.sigmoid_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sigmoid_backward : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSigmoidBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSigmoidBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCosineEmbeddingLossOp : Torch_Op<"aten.cosine_embedding_loss", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cosine_embedding_loss : (Tensor, Tensor, Tensor, float, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input1,
    AnyTorchTensorType:$input2,
    AnyTorchTensorType:$target,
    Torch_FloatType:$margin,
    Torch_IntType:$reduction
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCosineEmbeddingLossOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenCosineEmbeddingLossOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenDiagEmbedOp : Torch_Op<"aten.diag_embed", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::diag_embed : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$offset,
    Torch_IntType:$dim1,
    Torch_IntType:$dim2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiagEmbedOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenDiagEmbedOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenConstantPadNdOp : Torch_Op<"aten.constant_pad_nd", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::constant_pad_nd : (Tensor, int[], Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$pad,
    AnyTorchScalarType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenConstantPadNdOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenConstantPadNdOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenReplicationPad2dOp : Torch_Op<"aten.replication_pad2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::replication_pad2d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$padding
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReplicationPad2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenReplicationPad2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenReflectionPad1dOp : Torch_Op<"aten.reflection_pad1d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reflection_pad1d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$padding
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReflectionPad1dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenReflectionPad1dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenReflectionPad2dOp : Torch_Op<"aten.reflection_pad2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reflection_pad2d : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$padding
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReflectionPad2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenReflectionPad2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPadOp : Torch_Op<"aten.pad", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pad : (Tensor, int[], str, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$pad,
    Torch_StringType:$mode,
    AnyTorchOptionalFloatType:$value
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPadOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenPadOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSqueezeDimOp : Torch_Op<"aten.squeeze.dim", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze.dim : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSqueezeDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSqueezeOp : Torch_Op<"aten.squeeze", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqueezeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFlattenUsingIntsOp : Torch_Op<"aten.flatten.using_ints", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::flatten.using_ints : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$start_dim,
    Torch_IntType:$end_dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFlattenUsingIntsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenFlattenUsingIntsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenUnflattenIntOp : Torch_Op<"aten.unflatten.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unflatten.int : (Tensor, int, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchListOfTorchIntType:$sizes
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnflattenIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenUnflattenIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDimOp : Torch_Op<"aten.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::dim : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSizeOp : Torch_Op<"aten.size", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::size : (Tensor) -> (int[])`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchListOfTorchIntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSizeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSizeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenBoolTensorOp : Torch_Op<"aten.Bool.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Bool.Tensor : (Tensor) -> (bool)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBoolTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBoolTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIsFloatingPointOp : Torch_Op<"aten.is_floating_point", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::is_floating_point : (Tensor) -> (bool)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIsFloatingPointOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIsFloatingPointOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenOnesOp : Torch_Op<"aten.ones", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ones : (int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenOnesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenOnesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNewOnesOp : Torch_Op<"aten.new_ones", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_ones : (Tensor, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewOnesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenNewOnesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenZerosOp : Torch_Op<"aten.zeros", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::zeros : (int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZerosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenZerosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNewZerosOp : Torch_Op<"aten.new_zeros", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_zeros : (Tensor, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewZerosOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenNewZerosOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenEyeOp : Torch_Op<"aten.eye", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eye : (int, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    Torch_IntType:$n,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEyeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenEyeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenEyeMOp : Torch_Op<"aten.eye.m", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eye.m : (int, int, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    Torch_IntType:$n,
    Torch_IntType:$m,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEyeMOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEyeMOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenTensorOp : Torch_Op<"aten.tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor : (t[], int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListType:$data,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenTensorBoolOp : Torch_Op<"aten.tensor.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor.bool : (bool, int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_BoolType:$t,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenTensorIntOp : Torch_Op<"aten.tensor.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor.int : (int, int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_IntType:$t,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScalarTensorOp : Torch_Op<"aten.scalar_tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scalar_tensor : (Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$s,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScalarTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenScalarTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_Aten_ShapeAsTensorOp : Torch_Op<"aten._shape_as_tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_shape_as_tensor : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ShapeAsTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void Aten_ShapeAsTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenIsnanOp : Torch_Op<"aten.isnan", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::isnan : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIsnanOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIsnanOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIsinfOp : Torch_Op<"aten.isinf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::isinf : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIsinfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIsinfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIsneginfOp : Torch_Op<"aten.isneginf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::isneginf : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIsneginfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIsneginfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIsposinfOp : Torch_Op<"aten.isposinf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::isposinf : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIsposinfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIsposinfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAllOp : Torch_Op<"aten.all", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::all : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAllOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAllOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAllBoolOp : Torch_Op<"aten.all.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::all.bool : (bool[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchBoolType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAllBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAllBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAllDimOp : Torch_Op<"aten.all.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::all.dim : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAllDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAllDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAnyOp : Torch_Op<"aten.any", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::any : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAnyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAnyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAnyDimOp : Torch_Op<"aten.any.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::any.dim : (Tensor, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAnyDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAnyDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenArangeOp : Torch_Op<"aten.arange", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::arange : (Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$end,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenArangeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenArangeStartOp : Torch_Op<"aten.arange.start", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::arange.start : (Scalar, Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeStartOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenArangeStartOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenArangeStartStepOp : Torch_Op<"aten.arange.start_step", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::arange.start_step : (Scalar, Scalar, Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    AnyTorchScalarType:$step,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeStartStepOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenArangeStartStepOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenArangeStartOutOp : Torch_Op<"aten.arange.start_out", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::arange.start_out : (Scalar, Scalar, Scalar, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    AnyTorchScalarType:$step,
    AnyTorchTensorType:$out
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArangeStartOutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenArangeStartOutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenArgmaxOp : Torch_Op<"aten.argmax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::argmax : (Tensor, int?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArgmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenArgmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenArgminOp : Torch_Op<"aten.argmin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::argmin : (Tensor, int?, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenArgminOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenArgminOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenOneHotOp : Torch_Op<"aten.one_hot", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::one_hot : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$num_classes
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenOneHotOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenOneHotOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEinsumOp : Torch_Op<"aten.einsum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::einsum : (str, Tensor[], int[]?) -> (Tensor)`";
  let arguments = (ins
    Torch_StringType:$equation,
    AnyTorchListOfTensorType:$tensors,
    AnyTorchOptionalListOfTorchIntType:$path
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEinsumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenEinsumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenTraceOp : Torch_Op<"aten.trace", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::trace : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTraceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTraceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenBucketizeTensorOp : Torch_Op<"aten.bucketize.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::bucketize.Tensor : (Tensor, Tensor, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$boundaries,
    Torch_BoolType:$out_int32,
    Torch_BoolType:$right
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBucketizeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenBucketizeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenCloneOp : Torch_Op<"aten.clone", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::clone : (Tensor, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCloneOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenCloneOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLiftFreshCopyOp : Torch_Op<"aten.lift_fresh_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lift_fresh_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLiftFreshCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLiftFreshCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenContiguousOp : Torch_Op<"aten.contiguous", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::contiguous : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenContiguousOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenContiguousOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCopyOp : Torch_Op<"aten.copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::copy : (Tensor, Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_BoolType:$non_blocking
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenCopy_Op : Torch_Op<"aten.copy_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::copy_ : (Tensor, Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$src,
    Torch_BoolType:$non_blocking
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCopy_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenCopy_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_ToCopyOp : Torch_Op<"aten._to_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_to_copy : (Tensor, int?, int?, Device?, bool?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    Torch_BoolType:$non_blocking,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ToCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void Aten_ToCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenDetachOp : Torch_Op<"aten.detach", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::detach : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDetachOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDetachOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenDeviceWithIndexOp : Torch_Op<"aten.device.with_index", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::device.with_index : (str, int) -> (Device)`";
  let arguments = (ins
    Torch_StringType:$type,
    Torch_IntType:$index
  );
  let results = (outs
    Torch_DeviceType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDeviceWithIndexOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDeviceWithIndexOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenCudaOp : Torch_Op<"aten.cuda", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cuda : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCudaOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCudaOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenEmbeddingOp : Torch_Op<"aten.embedding", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::embedding : (Tensor, Tensor, int, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$weight,
    AnyTorchTensorType:$indices,
    Torch_IntType:$padding_idx,
    Torch_BoolType:$scale_grad_by_freq,
    Torch_BoolType:$sparse
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmbeddingOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenEmbeddingOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenEmbeddingBagPaddingIdxOp : Torch_Op<"aten.embedding_bag.padding_idx", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::embedding_bag.padding_idx : (Tensor, Tensor, Tensor, bool, int, bool, Tensor?, bool, int?) -> (Tensor, Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$weight,
    AnyTorchTensorType:$indices,
    AnyTorchTensorType:$offsets,
    Torch_BoolType:$scale_grad_by_freq,
    Torch_IntType:$mode,
    Torch_BoolType:$sparse,
    AnyTorchOptionalTensorType:$per_sample_weights,
    Torch_BoolType:$include_last_offset,
    AnyTorchOptionalIntType:$padding_idx
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2,
    AnyTorchTensorType:$result3
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmbeddingBagPaddingIdxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 4);
    }
    void AtenEmbeddingBagPaddingIdxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 4);
    }
  }];
}

def Torch_Aten_EmbeddingBagOp : Torch_Op<"aten._embedding_bag", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_embedding_bag : (Tensor, Tensor, Tensor, bool, int, bool, Tensor?, bool, int) -> (Tensor, Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$weight,
    AnyTorchTensorType:$indices,
    AnyTorchTensorType:$offsets,
    Torch_BoolType:$scale_grad_by_freq,
    Torch_IntType:$mode,
    Torch_BoolType:$sparse,
    AnyTorchOptionalTensorType:$per_sample_weights,
    Torch_BoolType:$include_last_offset,
    Torch_IntType:$padding_idx
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2,
    AnyTorchTensorType:$result3
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_EmbeddingBagOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 9, 4);
    }
    void Aten_EmbeddingBagOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 9, 4);
    }
  }];
}

def Torch_AtenEmptyLikeOp : Torch_Op<"aten.empty_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::empty_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmptyLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEmptyLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenNewEmptyOp : Torch_Op<"aten.new_empty", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_empty : (Tensor, int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewEmptyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenNewEmptyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenNewEmptyStridedOp : Torch_Op<"aten.new_empty_strided", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_empty_strided : (Tensor, int[], int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewEmptyStridedOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenNewEmptyStridedOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenZerosLikeOp : Torch_Op<"aten.zeros_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::zeros_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenZerosLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenZerosLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenOnesLikeOp : Torch_Op<"aten.ones_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ones_like : (Tensor, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenOnesLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenOnesLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenEmptyMemoryFormatOp : Torch_Op<"aten.empty.memory_format", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::empty.memory_format : (int[], int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmptyMemoryFormatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEmptyMemoryFormatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenEmptyStridedOp : Torch_Op<"aten.empty_strided", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::empty_strided : (int[], int[], int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmptyStridedOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEmptyStridedOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenExpandOp : Torch_Op<"aten.expand", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expand : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    Torch_BoolType:$implicit
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpandOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenExpandOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenExpandAsOp : Torch_Op<"aten.expand_as", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expand_as : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpandAsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenExpandAsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenBroadcastToOp : Torch_Op<"aten.broadcast_to", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::broadcast_to : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBroadcastToOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenBroadcastToOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenIndexTensorOp : Torch_Op<"aten.index.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index.Tensor : (Tensor, Tensor?[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenIndexTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenIndexTensorHackedTwinOp : Torch_Op<"aten.index.Tensor_hacked_twin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index.Tensor_hacked_twin : (Tensor, Tensor[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTensorType:$indices
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexTensorHackedTwinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenIndexTensorHackedTwinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenIndexSelectOp : Torch_Op<"aten.index_select", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::index_select : (Tensor, int, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIndexSelectOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenIndexSelectOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten_IndexPutImplOp : Torch_Op<"aten._index_put_impl", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_index_put_impl : (Tensor, Tensor?[], Tensor, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfOptionalTensorType:$indices,
    AnyTorchTensorType:$values,
    Torch_BoolType:$accumulate,
    Torch_BoolType:$unsafe
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_IndexPutImplOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void Aten_IndexPutImplOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_Aten_IndexPutImpl_Op : Torch_Op<"aten._index_put_impl_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::_index_put_impl_ : (Tensor, Tensor?[], Tensor, bool, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    AnyTorchListOfOptionalNonValueTensorType:$indices,
    Torch_NonValueTensorType:$values,
    Torch_BoolType:$accumulate,
    Torch_BoolType:$unsafe
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_IndexPutImpl_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void Aten_IndexPutImpl_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenItemOp : Torch_Op<"aten.item", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::item : (Tensor) -> (Scalar)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenItemOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenItemOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenMaskedSelectOp : Torch_Op<"aten.masked_select", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::masked_select : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$mask
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaskedSelectOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMaskedSelectOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNumelOp : Torch_Op<"aten.numel", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::numel : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNumelOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNumelOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenRepeatOp : Torch_Op<"aten.repeat", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::repeat : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$repeats
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRepeatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRepeatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTileOp : Torch_Op<"aten.tile", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tile : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTileOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTileOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenReshapeOp : Torch_Op<"aten.reshape", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reshape : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$shape
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReshapeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenReshapeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenReshapeAsOp : Torch_Op<"aten.reshape_as", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::reshape_as : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenReshapeAsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenReshapeAsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_ReshapeAliasOp : Torch_Op<"aten._reshape_alias", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_reshape_alias : (Tensor, int[], int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ReshapeAliasOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_ReshapeAliasOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenResizeOp : Torch_Op<"aten.resize", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::resize : (Tensor, int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenResizeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenResizeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenResize_Op : Torch_Op<"aten.resize_", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::resize_ : (Tensor, int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenResize_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenResize_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSelectIntOp : Torch_Op<"aten.select.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSelectIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSizeIntOp : Torch_Op<"aten.size.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::size.int : (Tensor, int) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSizeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSizeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSumOp : Torch_Op<"aten.sum", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sum : (Tensor, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenSumDimIntListOp : Torch_Op<"aten.sum.dim_IntList", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sum.dim_IntList : (Tensor, int[]?, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSumDimIntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSumDimIntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenProdDimIntOp : Torch_Op<"aten.prod.dim_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::prod.dim_int : (Tensor, int, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim,
    AnyTorchOptionalIntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenProdDimIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenProdDimIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenMaxOp : Torch_Op<"aten.max", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenMaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenMaxOtherOp : Torch_Op<"aten.max.other", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max.other : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxOtherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMaxOtherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenMaxDimOp : Torch_Op<"aten.max.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::max.dim : (Tensor, int, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$values,
    AnyTorchTensorType:$indices
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMaxDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 2);
    }
    void AtenMaxDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 2);
    }
  }];
}

def Torch_AtenAmaxOp : Torch_Op<"aten.amax", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::amax : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAmaxOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAmaxOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMinOp : Torch_Op<"aten.min", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::min : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenMinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenMinOtherOp : Torch_Op<"aten.min.other", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::min.other : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMinOtherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMinOtherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenMinDimOp : Torch_Op<"aten.min.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::min.dim : (Tensor, int, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$values,
    AnyTorchTensorType:$indices
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMinDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 2);
    }
    void AtenMinDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 2);
    }
  }];
}

def Torch_AtenAminOp : Torch_Op<"aten.amin", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::amin : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dim,
    Torch_BoolType:$keepdim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAminOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenAminOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenToDtypeOp : Torch_Op<"aten.to.dtype", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.dtype : (Tensor, int, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dtype,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToDtypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenToDtypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenToDtypeLayoutOp : Torch_Op<"aten.to.dtype_layout", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.dtype_layout : (Tensor, int?, int?, Device?, bool?, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToDtypeLayoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 1);
    }
    void AtenToDtypeLayoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_AtenToOtherOp : Torch_Op<"aten.to.other", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.other : (Tensor, Tensor, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToOtherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenToOtherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenToPrimDeviceOp : Torch_Op<"aten.to.prim_Device", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.prim_Device : (Tensor, Device?, int?, bool, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalIntType:$dtype,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToPrimDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenToPrimDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenToDeviceOp : Torch_Op<"aten.to.device", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::to.device : (Tensor, Device, int, bool, bool, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_DeviceType:$device,
    Torch_IntType:$dtype,
    Torch_BoolType:$non_blocking,
    Torch_BoolType:$copy,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenToDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenToDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenTypeAsOp : Torch_Op<"aten.type_as", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::type_as : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTypeAsOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTypeAsOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenViewOp : Torch_Op<"aten.view", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenViewOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten_UnsafeViewOp : Torch_Op<"aten._unsafe_view", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_unsafe_view : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_UnsafeViewOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten_UnsafeViewOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenWhereSelfOp : Torch_Op<"aten.where.self", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.self : (Tensor, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereSelfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereSelfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenWhereScalarOp : Torch_Op<"aten.where.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.Scalar : (Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchScalarType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenWhereScalarOtherOp : Torch_Op<"aten.where.ScalarOther", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.ScalarOther : (Tensor, Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereScalarOtherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereScalarOtherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenWhereScalarSelfOp : Torch_Op<"aten.where.ScalarSelf", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::where.ScalarSelf : (Tensor, Scalar, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$condition,
    AnyTorchScalarType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWhereScalarSelfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenWhereScalarSelfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNanToNumOp : Torch_Op<"aten.nan_to_num", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::nan_to_num : (Tensor, float?, float?, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalFloatType:$nan,
    AnyTorchOptionalFloatType:$posinf,
    AnyTorchOptionalFloatType:$neginf
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNanToNumOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenNanToNumOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSliceTensorOp : Torch_Op<"aten.slice.Tensor", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice.Tensor : (Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenSliceTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLenTensorOp : Torch_Op<"aten.len.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::len.Tensor : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$t
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLenTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLenTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenCpuOp : Torch_Op<"aten.cpu", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cpu : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCpuOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCpuOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenGatherOp : Torch_Op<"aten.gather", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gather : (Tensor, int, Tensor, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    Torch_BoolType:$sparse_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGatherOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenGatherOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatterAddOp : Torch_Op<"aten.scatter_add", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scatter_add : (Tensor, int, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    AnyTorchTensorType:$src
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterAddOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatterAddOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatterAdd_Op : Torch_Op<"aten.scatter_add_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::scatter_add_ : (Tensor, int, Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$dim,
    Torch_NonValueTensorType:$index,
    Torch_NonValueTensorType:$src
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterAdd_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenScatterAdd_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScatterReduceTwoOp : Torch_Op<"aten.scatter_reduce.two", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scatter_reduce.two : (Tensor, int, Tensor, Tensor, str, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    AnyTorchTensorType:$src,
    Torch_StringType:$reduce,
    Torch_BoolType:$include_self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterReduceTwoOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenScatterReduceTwoOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenScatterReduce_TwoOp : Torch_Op<"aten.scatter_reduce_.two", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::scatter_reduce_.two : (Tensor, int, Tensor, Tensor, str, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_IntType:$dim,
    Torch_NonValueTensorType:$index,
    Torch_NonValueTensorType:$src,
    Torch_StringType:$reduce,
    Torch_BoolType:$include_self
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterReduce_TwoOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenScatterReduce_TwoOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenIntImplicitOp : Torch_Op<"aten.IntImplicit", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::IntImplicit : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntImplicitOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntImplicitOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenFloatImplicitOp : Torch_Op<"aten.FloatImplicit", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::FloatImplicit : (Tensor) -> (float)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatImplicitOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatImplicitOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenTensorFloatOp : Torch_Op<"aten.tensor.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tensor.float : (float, int?, Device?, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_FloatType:$t,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalDeviceType:$device,
    Torch_BoolType:$requires_grad
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTensorFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenTensorFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIntTensorOp : Torch_Op<"aten.Int.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.Tensor : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenFloatTensorOp : Torch_Op<"aten.Float.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Float.Tensor : (Tensor) -> (float)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenDropoutOp : Torch_Op<"aten.dropout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::dropout : (Tensor, float, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    Torch_FloatType:$p,
    Torch_BoolType:$train
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDropoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDropoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDropout_Op : Torch_Op<"aten.dropout_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::dropout_ : (Tensor, float, bool) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_FloatType:$p,
    Torch_BoolType:$train
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDropout_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenDropout_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenNativeDropoutOp : Torch_Op<"aten.native_dropout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_dropout : (Tensor, float, bool?) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    Torch_FloatType:$p,
    AnyTorchOptionalBoolType:$train
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeDropoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 2);
    }
    void AtenNativeDropoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 2);
    }
  }];
}

def Torch_AtenTOp : Torch_Op<"aten.t", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::t : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenNumpyTOp : Torch_Op<"aten.numpy_T", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::numpy_T : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNumpyTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNumpyTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFullOp : Torch_Op<"aten.full", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::full : (int[], Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$size,
    AnyTorchScalarType:$fill_value,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFullOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenFullOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFullLikeOp : Torch_Op<"aten.full_like", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::full_like : (Tensor, Scalar, int?, int?, Device?, bool?, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$fill_value,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory,
    AnyTorchOptionalIntType:$memory_format
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFullLikeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenFullLikeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenNewFullOp : Torch_Op<"aten.new_full", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::new_full : (Tensor, int[], Scalar, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchScalarType:$fill_value,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNewFullOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenNewFullOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenBaddbmmOp : Torch_Op<"aten.baddbmm", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::baddbmm : (Tensor, Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$batch1,
    AnyTorchTensorType:$batch2,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBaddbmmOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenBaddbmmOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenBaddbmm_Op : Torch_Op<"aten.baddbmm_", [
    IsTrailingUnderscoreInplaceVariant,
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::baddbmm_ : (Tensor, Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    Torch_NonValueTensorType:$self,
    Torch_NonValueTensorType:$batch1,
    Torch_NonValueTensorType:$batch2,
    AnyTorchScalarType:$beta,
    AnyTorchScalarType:$alpha
  );
  let results = (outs
    Torch_NonValueTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBaddbmm_Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenBaddbmm_Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenFftFftOp : Torch_Op<"aten.fft_fft", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fft_fft : (Tensor, int?, int, str?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchOptionalIntType:$n,
    Torch_IntType:$dim,
    AnyTorchOptionalStringType:$norm
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFftFftOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenFftFftOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenFmodTensorOp : Torch_Op<"aten.fmod.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::fmod.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFmodTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFmodTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUniqueConsecutiveOp : Torch_Op<"aten.unique_consecutive", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unique_consecutive : (Tensor, bool, bool, int?) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_BoolType:$return_inverse,
    Torch_BoolType:$return_counts,
    AnyTorchOptionalIntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUniqueConsecutiveOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 3);
    }
    void AtenUniqueConsecutiveOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 3);
    }
  }];
}

def Torch_AtenLinspaceOp : Torch_Op<"aten.linspace", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linspace : (Scalar, Scalar, int, int?, int?, Device?, bool?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$start,
    AnyTorchScalarType:$end,
    Torch_IntType:$steps,
    AnyTorchOptionalIntType:$dtype,
    AnyTorchOptionalIntType:$layout,
    AnyTorchOptionalDeviceType:$device,
    AnyTorchOptionalBoolType:$pin_memory
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinspaceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenLinspaceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenLinalgCrossOp : Torch_Op<"aten.linalg_cross", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::linalg_cross : (Tensor, Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLinalgCrossOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenLinalgCrossOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasVerifier = 1;
}

def Torch_AtenAliasCopyOp : Torch_Op<"aten.alias_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::alias_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAliasCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAliasCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAliasOp : Torch_Op<"aten.alias", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::alias : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAliasOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAliasOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenAsStridedCopyOp : Torch_Op<"aten.as_strided_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::as_strided_copy : (Tensor, int[], int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchOptionalIntType:$storage_offset
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsStridedCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenAsStridedCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenDiagonalOp : Torch_Op<"aten.diagonal", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::diagonal : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$offset,
    Torch_IntType:$dim1,
    Torch_IntType:$dim2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiagonalOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenDiagonalOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenDiagonalCopyOp : Torch_Op<"aten.diagonal_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::diagonal_copy : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$offset,
    Torch_IntType:$dim1,
    Torch_IntType:$dim2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiagonalCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenDiagonalCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenExpandCopyOp : Torch_Op<"aten.expand_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::expand_copy : (Tensor, int[], bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    Torch_BoolType:$implicit
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenExpandCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenExpandCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenPermuteCopyOp : Torch_Op<"aten.permute_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::permute_copy : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$dims
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPermuteCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPermuteCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_Aten_ReshapeAliasCopyOp : Torch_Op<"aten._reshape_alias_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_reshape_alias_copy : (Tensor, int[], int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_ReshapeAliasCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_ReshapeAliasCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSelectCopyIntOp : Torch_Op<"aten.select_copy.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select_copy.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectCopyIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSelectCopyIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDetachCopyOp : Torch_Op<"aten.detach_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::detach_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDetachCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDetachCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSliceCopyTensorOp : Torch_Op<"aten.slice_copy.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice_copy.Tensor : (Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceCopyTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenSliceCopyTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenSqueezeCopyOp : Torch_Op<"aten.squeeze_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqueezeCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSqueezeCopyDimOp : Torch_Op<"aten.squeeze_copy.dim", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::squeeze_copy.dim : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqueezeCopyDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSqueezeCopyDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenTCopyOp : Torch_Op<"aten.t_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::t_copy : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenTCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenTransposeCopyIntOp : Torch_Op<"aten.transpose_copy.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::transpose_copy.int : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim0,
    Torch_IntType:$dim1
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTransposeCopyIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenTransposeCopyIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenUnsqueezeCopyOp : Torch_Op<"aten.unsqueeze_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unsqueeze_copy : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnsqueezeCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnsqueezeCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenViewCopyOp : Torch_Op<"aten.view_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view_copy : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$size
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenViewCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenViewCopyDtypeOp : Torch_Op<"aten.view_copy.dtype", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::view_copy.dtype : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenViewCopyDtypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenViewCopyDtypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenUnfoldCopyOp : Torch_Op<"aten.unfold_copy", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unfold_copy : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dimension,
    Torch_IntType:$size,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnfoldCopyOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenUnfoldCopyOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenIm2colOp : Torch_Op<"aten.im2col", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::im2col : (Tensor, int[], int[], int[], int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$kernel_size,
    AnyTorchListOfTorchIntType:$dilation,
    AnyTorchListOfTorchIntType:$padding,
    AnyTorchListOfTorchIntType:$stride
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIm2colOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenIm2colOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenScatterReduceOp : Torch_Op<"aten.scatter.reduce", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scatter.reduce : (Tensor, int, Tensor, Tensor, str) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$index,
    AnyTorchTensorType:$src,
    Torch_StringType:$reduce
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScatterReduceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenScatterReduceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenSelectScatterOp : Torch_Op<"aten.select_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::select_scatter : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$dim,
    Torch_IntType:$index
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSelectScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSelectScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenSliceScatterOp : Torch_Op<"aten.slice_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice_scatter : (Tensor, Tensor, int, int?, int?, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$dim,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenSliceScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenDiagonalScatterOp : Torch_Op<"aten.diagonal_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::diagonal_scatter : (Tensor, Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    Torch_IntType:$offset,
    Torch_IntType:$dim1,
    Torch_IntType:$dim2
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDiagonalScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenDiagonalScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenAsStridedScatterOp : Torch_Op<"aten.as_strided_scatter", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::as_strided_scatter : (Tensor, Tensor, int[], int[], int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$src,
    AnyTorchListOfTorchIntType:$size,
    AnyTorchListOfTorchIntType:$stride,
    AnyTorchOptionalIntType:$storage_offset
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAsStridedScatterOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenAsStridedScatterOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenUpsampleNearest2dOp : Torch_Op<"aten.upsample_nearest2d", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::upsample_nearest2d : (Tensor, int[], float?, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$output_size,
    AnyTorchOptionalFloatType:$scales_h,
    AnyTorchOptionalFloatType:$scales_w
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUpsampleNearest2dOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenUpsampleNearest2dOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScaledDotProductAttentionOp : Torch_Op<"aten.scaled_dot_product_attention", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::scaled_dot_product_attention : (Tensor, Tensor, Tensor, Tensor?, float, bool, float?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$query,
    AnyTorchTensorType:$key,
    AnyTorchTensorType:$value,
    AnyTorchOptionalTensorType:$attn_mask,
    Torch_FloatType:$dropout_p,
    Torch_BoolType:$is_causal,
    AnyTorchOptionalFloatType:$scale
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScaledDotProductAttentionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 7, 1);
    }
    void AtenScaledDotProductAttentionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 7, 1);
    }
  }];
}

def Torch_AtenGridSamplerOp : Torch_Op<"aten.grid_sampler", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::grid_sampler : (Tensor, Tensor, int, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$grid,
    Torch_IntType:$interpolation_mode,
    Torch_IntType:$padding_mode,
    Torch_BoolType:$align_corners
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGridSamplerOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenGridSamplerOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_Aten__Contains__StrOp : Torch_Op<"aten.__contains__.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__contains__.str : (Dict(str, t), str) -> (bool)`";
  let arguments = (ins
    Torch_DictType:$dict,
    Torch_StringType:$key
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Contains__StrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Contains__StrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Contains__IntListOp : Torch_Op<"aten.__contains__.int_list", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__contains__.int_list : (int[], int) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$l,
    Torch_IntType:$item
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Contains__IntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Contains__IntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Getitem__DictStrOp : Torch_Op<"aten.__getitem__.Dict_str", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__getitem__.Dict_str : (Dict(str, t), str) -> (t)`";
  let arguments = (ins
    Torch_DictType:$self,
    Torch_StringType:$key
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Getitem__DictStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Getitem__DictStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten_SetItemStrOp : Torch_Op<"aten._set_item.str", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::_set_item.str : (Dict(str, t), str, t) -> ()`";
  let arguments = (ins
    Torch_DictType:$l,
    Torch_StringType:$idx,
    AnyTorchType:$v
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SetItemStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 0);
    }
    void Aten_SetItemStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 0);
    }
  }];
}

def Torch_AtenKeysStrOp : Torch_Op<"aten.keys.str", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::keys.str : (Dict(str, t)) -> (str[])`";
  let arguments = (ins
    Torch_DictType:$self
  );
  let results = (outs
    AnyTorchListOfTorchStringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenKeysStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenKeysStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenGetDefaultStrOp : Torch_Op<"aten.get.default_str", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::get.default_str : (Dict(str, t), str, t) -> (t)`";
  let arguments = (ins
    Torch_DictType:$self,
    Torch_StringType:$key,
    AnyTorchType:$default_value
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGetDefaultStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenGetDefaultStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenDeleteDictStrOp : Torch_Op<"aten.Delete.Dict_str", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::Delete.Dict_str : (Dict(str, t), str) -> ()`";
  let arguments = (ins
    Torch_DictType:$self,
    Torch_StringType:$key
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDeleteDictStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 0);
    }
    void AtenDeleteDictStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 0);
    }
  }];
}

def Torch_AtenCatOp : Torch_Op<"aten.cat", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::cat : (Tensor[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTensorType:$tensors,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenCatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_AtenStackOp : Torch_Op<"aten.stack", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::stack : (Tensor[], int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchListOfTensorType:$tensors,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStackOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenStackOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAppendTOp : Torch_Op<"aten.append.t", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::append.t : (t[], t) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$self,
    AnyTorchType:$el
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAppendTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAppendTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddTOp : Torch_Op<"aten.add.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.t : (t[], t[]) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$a,
    AnyTorchListType:$b
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenEqIntListOp : Torch_Op<"aten.eq.int_list", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.int_list : (int[], int[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$a,
    AnyTorchListOfTorchIntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqIntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqIntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenListTOp : Torch_Op<"aten.list.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::list.t : (t[]) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$l
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenListTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenListTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenSliceTOp : Torch_Op<"aten.slice.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::slice.t : (t[], int?, int?, int) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$l,
    AnyTorchOptionalIntType:$start,
    AnyTorchOptionalIntType:$end,
    Torch_IntType:$step
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSliceTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenSliceTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenInsertTOp : Torch_Op<"aten.insert.t", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::insert.t : (t[], int, t) -> ()`";
  let arguments = (ins
    AnyTorchListType:$self,
    Torch_IntType:$idx,
    AnyTorchType:$el
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenInsertTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 0);
    }
    void AtenInsertTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 0);
    }
  }];
}

def Torch_AtenNeIntListOp : Torch_Op<"aten.ne.int_list", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.int_list : (int[], int[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$a,
    AnyTorchListOfTorchIntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeIntListOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeIntListOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAnyBoolOp : Torch_Op<"aten.any.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::any.bool : (bool[]) -> (bool)`";
  let arguments = (ins
    AnyTorchListOfTorchBoolType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAnyBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenAnyBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSortIntOp : Torch_Op<"aten.sort.int", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::sort.int : (int[], bool) -> ()`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$self,
    Torch_BoolType:$reverse
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSortIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 0);
    }
    void AtenSortIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 0);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_AtenSortOp : Torch_Op<"aten.sort", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sort : (Tensor, int, bool) -> (Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_BoolType:$descending
  );
  let results = (outs
    AnyTorchTensorType:$values,
    AnyTorchTensorType:$indices
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSortOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 2);
    }
    void AtenSortOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 2);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSplitTensorOp : Torch_Op<"aten.split.Tensor", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::split.Tensor : (Tensor, int, int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$split_size,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSplitTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSplitTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSplitWithSizesOp : Torch_Op<"aten.split_with_sizes", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::split_with_sizes : (Tensor, int[], int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$split_sizes,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSplitWithSizesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSplitWithSizesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenSplitSizesOp : Torch_Op<"aten.split.sizes", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::split.sizes : (Tensor, int[], int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchListOfTorchIntType:$split_size,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSplitSizesOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenSplitSizesOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenUnbindIntOp : Torch_Op<"aten.unbind.int", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::unbind.int : (Tensor, int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenUnbindIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenUnbindIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenChunkOp : Torch_Op<"aten.chunk", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::chunk : (Tensor, int, int) -> (Tensor[])`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$chunks,
    Torch_IntType:$dim
  );
  let results = (outs
    AnyTorchListOfTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenChunkOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenChunkOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenAddStrOp : Torch_Op<"aten.add.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.str : (str, str) -> (str)`";
  let arguments = (ins
    Torch_StringType:$a,
    Torch_StringType:$b
  );
  let results = (outs
    Torch_StringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenEqStrOp : Torch_Op<"aten.eq.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.str : (str, str) -> (bool)`";
  let arguments = (ins
    Torch_StringType:$a,
    Torch_StringType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLenStrOp : Torch_Op<"aten.len.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::len.str : (str) -> (int)`";
  let arguments = (ins
    Torch_StringType:$s
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLenStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLenStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenStrOp : Torch_Op<"aten.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::str : (t) -> (str)`";
  let arguments = (ins
    AnyTorchType:$elem
  );
  let results = (outs
    Torch_StringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenFormatOp : Torch_Op<"aten.format", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::format : (...) -> (str)`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
    Torch_StringType:$result
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands)) `->` qualified(type($result))";
}

def Torch_AtenJoinOp : Torch_Op<"aten.join", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::join : (str, str[]) -> (str)`";
  let arguments = (ins
    Torch_StringType:$self,
    AnyTorchListOfTorchStringType:$values
  );
  let results = (outs
    Torch_StringType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenJoinOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenJoinOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenWarnOp : Torch_Op<"aten.warn", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::warn : (str, int) -> ()`";
  let arguments = (ins
    Torch_StringType:$message,
    Torch_IntType:$stacklevel
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenWarnOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 0);
    }
    void AtenWarnOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 0);
    }
  }];
}

def Torch_AtenFloatScalarOp : Torch_Op<"aten.Float.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Float.Scalar : (Scalar) -> (float)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFloatStrOp : Torch_Op<"aten.Float.str", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Float.str : (str) -> (float)`";
  let arguments = (ins
    Torch_StringType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloatStrOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenFloatStrOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIntFloatOp : Torch_Op<"aten.Int.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.float : (float) -> (int)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenIntScalarOp : Torch_Op<"aten.Int.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.Scalar : (Scalar) -> (int)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenIntBoolOp : Torch_Op<"aten.Int.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Int.bool : (bool) -> (int)`";
  let arguments = (ins
    Torch_BoolType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__RangeLengthOp : Torch_Op<"aten.__range_length", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__range_length : (int, int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$lo,
    Torch_IntType:$hi,
    Torch_IntType:$step
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__RangeLengthOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten__RangeLengthOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__DeriveIndexOp : Torch_Op<"aten.__derive_index", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__derive_index : (int, int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$index,
    Torch_IntType:$start,
    Torch_IntType:$step
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__DeriveIndexOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten__DeriveIndexOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGtIntOp : Torch_Op<"aten.gt.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGeIntOp : Torch_Op<"aten.ge.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLtIntOp : Torch_Op<"aten.lt.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLeIntOp : Torch_Op<"aten.le.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::le.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNeIntOp : Torch_Op<"aten.ne.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEqIntOp : Torch_Op<"aten.eq.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.int : (int, int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenFloordivIntOp : Torch_Op<"aten.floordiv.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::floordiv.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenFloordivIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenFloordivIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenRemainderIntOp : Torch_Op<"aten.remainder.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::remainder.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRemainderIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRemainderIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenRemainderScalarOp : Torch_Op<"aten.remainder.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::remainder.Scalar : (Tensor, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRemainderScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRemainderScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenRemainderTensorOp : Torch_Op<"aten.remainder.Tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::remainder.Tensor : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$other
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenRemainderTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenRemainderTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenAddIntOp : Torch_Op<"aten.add.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSubIntOp : Torch_Op<"aten.sub.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSubIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenMulIntOp : Torch_Op<"aten.mul.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenDivIntOp : Torch_Op<"aten.div.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.int : (int, int) -> (float)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNegIntOp : Torch_Op<"aten.neg.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::neg.int : (int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNegIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNegIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLogIntOp : Torch_Op<"aten.log.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::log.int : (int) -> (float)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLogIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLogIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenAddFloatIntOp : Torch_Op<"aten.add.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add.float_int : (float, int) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSubFloatOp : Torch_Op<"aten.sub.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub.float : (float, float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSubFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenMulFloatOp : Torch_Op<"aten.mul.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul.float : (float, float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenDivFloatOp : Torch_Op<"aten.div.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div.float : (float, float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNegFloatOp : Torch_Op<"aten.neg.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::neg.float : (float) -> (float)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNegFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenNegFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEqFloatOp : Torch_Op<"aten.eq.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGtFloatOp : Torch_Op<"aten.gt.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenGeFloatOp : Torch_Op<"aten.ge.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLtFloatOp : Torch_Op<"aten.lt.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.float : (float, float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLtFloatIntOp : Torch_Op<"aten.lt.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::lt.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLtFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenLtFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGeFloatIntOp : Torch_Op<"aten.ge.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ge.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGeFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeFloatIntOp : Torch_Op<"aten.ne.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenGtFloatIntOp : Torch_Op<"aten.gt.float_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gt.float_int : (float, int) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGtFloatIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenGtFloatIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenPowIntFloatOp : Torch_Op<"aten.pow.int_float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::pow.int_float : (int, float) -> (float)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_FloatType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenPowIntFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenPowIntFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__And__BoolOp : Torch_Op<"aten.__and__.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__and__.bool : (bool, bool) -> (bool)`";
  let arguments = (ins
    Torch_BoolType:$a,
    Torch_BoolType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__And__BoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__And__BoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenNeBoolOp : Torch_Op<"aten.ne.bool", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ne.bool : (bool, bool) -> (bool)`";
  let arguments = (ins
    Torch_BoolType:$a,
    Torch_BoolType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNeBoolOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenNeBoolOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Is__Op : Torch_Op<"aten.__is__", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__is__ : (t1, t2) -> (bool)`";
  let arguments = (ins
    AnyTorchType:$self,
    AnyTorchType:$obj
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Is__Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Is__Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Isnot__Op : Torch_Op<"aten.__isnot__", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__isnot__ : (t1, t2) -> (bool)`";
  let arguments = (ins
    AnyTorchType:$self,
    AnyTorchType:$obj
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Isnot__Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Isnot__Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_Aten__Not__Op : Torch_Op<"aten.__not__", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__not__ : (bool) -> (bool)`";
  let arguments = (ins
    Torch_BoolType:$self
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Not__Op::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void Aten__Not__Op::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenLenTOp : Torch_Op<"aten.len.t", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::len.t : (t[]) -> (int)`";
  let arguments = (ins
    AnyTorchListType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLenTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenLenTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def Torch_Aten__Getitem__TOp : Torch_Op<"aten.__getitem__.t", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::__getitem__.t : (t[], int) -> (t)`";
  let arguments = (ins
    AnyTorchListType:$list,
    Torch_IntType:$idx
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten__Getitem__TOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void Aten__Getitem__TOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_Aten_SetItemTOp : Torch_Op<"aten._set_item.t", [
    AllowsTypeRefinement
  ]> {
  let summary = "Generated op for `aten::_set_item.t : (t[], int, t) -> (t[])`";
  let arguments = (ins
    AnyTorchListType:$l,
    Torch_IntType:$idx,
    AnyTorchType:$el
  );
  let results = (outs
    AnyTorchListType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SetItemTOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_SetItemTOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenMulOp : Torch_Op<"aten.mul", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::mul : (Scalar, Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a,
    AnyTorchScalarType:$b
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenMulOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenMulOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenDivOp : Torch_Op<"aten.div", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::div : (Scalar, Scalar) -> (float)`";
  let arguments = (ins
    AnyTorchScalarType:$a,
    AnyTorchScalarType:$b
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDivOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenDivOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenAddOp : Torch_Op<"aten.add", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::add : (Scalar, Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a,
    AnyTorchScalarType:$b
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenAddOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenAddOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSubOp : Torch_Op<"aten.sub", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sub : (Scalar, Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a,
    AnyTorchScalarType:$b
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSubOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenSubOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenCeilScalarOp : Torch_Op<"aten.ceil.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ceil.Scalar : (Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeilScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeilScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenSqrtIntOp : Torch_Op<"aten.sqrt.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::sqrt.int : (int) -> (float)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_FloatType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenSqrtIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenSqrtIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenBoolFloatOp : Torch_Op<"aten.Bool.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Bool.float : (float) -> (bool)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBoolFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBoolFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenBoolIntOp : Torch_Op<"aten.Bool.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::Bool.int : (int) -> (bool)`";
  let arguments = (ins
    Torch_IntType:$a
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenBoolIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenBoolIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenEqDeviceOp : Torch_Op<"aten.eq.device", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::eq.device : (Device, Device) -> (bool)`";
  let arguments = (ins
    Torch_DeviceType:$a,
    Torch_DeviceType:$b
  );
  let results = (outs
    Torch_BoolType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEqDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenEqDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenCeilFloatOp : Torch_Op<"aten.ceil.float", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ceil.float : (float) -> (int)`";
  let arguments = (ins
    Torch_FloatType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenCeilFloatOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenCeilFloatOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_AtenNarrowOp : Torch_Op<"aten.narrow", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::narrow : (Tensor, int, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    Torch_IntType:$start,
    Torch_IntType:$length
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNarrowOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenNarrowOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenNarrowTensorOp : Torch_Op<"aten.narrow.Tensor", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::narrow.Tensor : (Tensor, int, Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_IntType:$dim,
    AnyTorchTensorType:$start,
    Torch_IntType:$length
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNarrowTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenNarrowTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenScalarImplicitOp : Torch_Op<"aten.ScalarImplicit", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::ScalarImplicit : (Tensor) -> (Scalar)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenScalarImplicitOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenScalarImplicitOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_Aten_SoftmaxBackwardDataOp : Torch_Op<"aten._softmax_backward_data", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_softmax_backward_data : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output,
    Torch_IntType:$dim,
    Torch_IntType:$input_dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_SoftmaxBackwardDataOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void Aten_SoftmaxBackwardDataOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenTanhBackwardOp : Torch_Op<"aten.tanh_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::tanh_backward : (Tensor, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenTanhBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void AtenTanhBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_AtenHardtanhBackwardOp : Torch_Op<"aten.hardtanh_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::hardtanh_backward : (Tensor, Tensor, Scalar, Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$min_val,
    AnyTorchScalarType:$max_val
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenHardtanhBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenHardtanhBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenGeluBackwardOp : Torch_Op<"aten.gelu_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::gelu_backward : (Tensor, Tensor, str) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    Torch_StringType:$approximate
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenGeluBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenGeluBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_Aten_LogSoftmaxBackwardDataOp : Torch_Op<"aten._log_softmax_backward_data", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_log_softmax_backward_data : (Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$output,
    Torch_IntType:$dim,
    Torch_IntType:$input_dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_LogSoftmaxBackwardDataOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void Aten_LogSoftmaxBackwardDataOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenNativeLayerNormBackwardOp : Torch_Op<"aten.native_layer_norm_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_layer_norm_backward : (Tensor, Tensor, int[], Tensor, Tensor, Tensor?, Tensor?, bool[]) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_out,
    AnyTorchTensorType:$input,
    AnyTorchListOfTorchIntType:$normalized_shape,
    AnyTorchTensorType:$mean,
    AnyTorchTensorType:$rstd,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$bias,
    AnyTorchListOfTorchBoolType:$output_mask
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeLayerNormBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 8, 3);
    }
    void AtenNativeLayerNormBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 8, 3);
    }
  }];
}

def Torch_AtenEmbeddingDenseBackwardOp : Torch_Op<"aten.embedding_dense_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::embedding_dense_backward : (Tensor, Tensor, int, int, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$indices,
    Torch_IntType:$num_weights,
    Torch_IntType:$padding_idx,
    Torch_BoolType:$scale_grad_by_freq
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEmbeddingDenseBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenEmbeddingDenseBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenNativeBatchNormBackwardOp : Torch_Op<"aten.native_batch_norm_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_batch_norm_backward : (Tensor, Tensor, Tensor?, Tensor?, Tensor?, Tensor?, Tensor?, bool, float, bool[]) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_out,
    AnyTorchTensorType:$input,
    AnyTorchOptionalTensorType:$weight,
    AnyTorchOptionalTensorType:$running_mean,
    AnyTorchOptionalTensorType:$running_var,
    AnyTorchOptionalTensorType:$save_mean,
    AnyTorchOptionalTensorType:$save_invstd,
    Torch_BoolType:$train,
    Torch_FloatType:$eps,
    AnyTorchListOfTorchBoolType:$output_mask
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeBatchNormBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 10, 3);
    }
    void AtenNativeBatchNormBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 10, 3);
    }
  }];
}

def Torch_AtenNativeGroupNormBackwardOp : Torch_Op<"aten.native_group_norm_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_group_norm_backward : (Tensor, Tensor, Tensor, Tensor, Tensor?, int, int, int, int, bool[]) -> (Tensor, Tensor, Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_out,
    AnyTorchTensorType:$input,
    AnyTorchTensorType:$mean,
    AnyTorchTensorType:$rstd,
    AnyTorchOptionalTensorType:$weight,
    Torch_IntType:$N,
    Torch_IntType:$C,
    Torch_IntType:$HxW,
    Torch_IntType:$group,
    AnyTorchListOfTorchBoolType:$output_mask
  );
  let results = (outs
    AnyTorchTensorType:$result0,
    AnyTorchTensorType:$result1,
    AnyTorchTensorType:$result2
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeGroupNormBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 10, 3);
    }
    void AtenNativeGroupNormBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 10, 3);
    }
  }];
}

def Torch_AtenNativeDropoutBackwardOp : Torch_Op<"aten.native_dropout_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::native_dropout_backward : (Tensor, Tensor, float) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$mask,
    Torch_FloatType:$scale
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenNativeDropoutBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void AtenNativeDropoutBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_AtenEluBackwardOp : Torch_Op<"aten.elu_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::elu_backward : (Tensor, Scalar, Scalar, Scalar, bool, Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchScalarType:$alpha,
    AnyTorchScalarType:$scale,
    AnyTorchScalarType:$input_scale,
    Torch_BoolType:$is_result,
    AnyTorchTensorType:$self_or_result
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenEluBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 6, 1);
    }
    void AtenEluBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 6, 1);
    }
  }];
}

def Torch_AtenLeakyReluBackwardOp : Torch_Op<"aten.leaky_relu_backward", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::leaky_relu_backward : (Tensor, Tensor, Scalar, bool) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$grad_output,
    AnyTorchTensorType:$self,
    AnyTorchScalarType:$negative_slope,
    Torch_BoolType:$self_is_result
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenLeakyReluBackwardOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenLeakyReluBackwardOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenQuantizePerChannelOp : Torch_Op<"aten.quantize_per_channel", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::quantize_per_channel : (Tensor, Tensor, Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$scales,
    AnyTorchTensorType:$zero_points,
    Torch_IntType:$axis,
    Torch_IntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenQuantizePerChannelOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 5, 1);
    }
    void AtenQuantizePerChannelOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 5, 1);
    }
  }];
}

def Torch_AtenQuantizePerTensorOp : Torch_Op<"aten.quantize_per_tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::quantize_per_tensor : (Tensor, float, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$scale,
    Torch_IntType:$zero_point,
    Torch_IntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenQuantizePerTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void AtenQuantizePerTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_AtenDequantizeSelfOp : Torch_Op<"aten.dequantize.self", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::dequantize.self : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDequantizeSelfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDequantizeSelfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenDequantizeTensorOp : Torch_Op<"aten.dequantize.tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::dequantize.tensor : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$qtensor
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenDequantizeTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenDequantizeTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_AtenIntReprOp : Torch_Op<"aten.int_repr", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::int_repr : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult AtenIntReprOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void AtenIntReprOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_Aten_MakePerChannelQuantizedTensorOp : Torch_Op<"aten._make_per_channel_quantized_tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_make_per_channel_quantized_tensor : (Tensor, Tensor, Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    AnyTorchTensorType:$scale,
    AnyTorchTensorType:$zero_point,
    Torch_IntType:$axis
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_MakePerChannelQuantizedTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void Aten_MakePerChannelQuantizedTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_Aten_MakePerTensorQuantizedTensorOp : Torch_Op<"aten._make_per_tensor_quantized_tensor", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `aten::_make_per_tensor_quantized_tensor : (Tensor, float, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self,
    Torch_FloatType:$scale,
    Torch_IntType:$zero_point
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult Aten_MakePerTensorQuantizedTensorOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void Aten_MakePerTensorQuantizedTensorOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_PrimLayoutOp : Torch_Op<"prim.layout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::layout : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimLayoutOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimLayoutOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimTupleIndexOp : Torch_Op<"prim.TupleIndex", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::TupleIndex : (Any, int) -> (Any)`";
  let arguments = (ins
    AnyTorchType:$tup,
    Torch_IntType:$i
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimTupleIndexOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimTupleIndexOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_PrimDeviceOp : Torch_Op<"prim.device", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::device : (Tensor) -> (Device)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_DeviceType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimDeviceOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimDeviceOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_PrimDtypeOp : Torch_Op<"prim.dtype", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::dtype : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimDtypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimDtypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimTupleUnpackOp : Torch_Op<"prim.TupleUnpack", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::TupleUnpack : (Any) -> (...)`";
  let arguments = (ins
    AnyTorchType:$tup
  );
  let results = (outs
    Variadic<AnyTorchType>:$results
  );
  let assemblyFormat = "$tup attr-dict `:` qualified(type($tup)) `->` qualified(type($results))";
  let hasCanonicalizer = 1;
}

def Torch_PrimNumToTensorScalarOp : Torch_Op<"prim.NumToTensor.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::NumToTensor.Scalar : (Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimNumToTensorScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimNumToTensorScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimMinSelfIntOp : Torch_Op<"prim.min.self_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::min.self_int : (int[]) -> (int)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMinSelfIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimMinSelfIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimMinIntOp : Torch_Op<"prim.min.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::min.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMinIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimMinIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimMaxSelfIntOp : Torch_Op<"prim.max.self_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::max.self_int : (int[]) -> (int)`";
  let arguments = (ins
    AnyTorchListOfTorchIntType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMaxSelfIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimMaxSelfIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimMaxIntOp : Torch_Op<"prim.max.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::max.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimMaxIntOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimMaxIntOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimRaiseExceptionOp : Torch_Op<"prim.RaiseException", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::RaiseException : (str, str?) -> ()`";
  let arguments = (ins
    Torch_StringType:$msg,
    AnyTorchOptionalStringType:$cls
  );
  let results = (outs
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimRaiseExceptionOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 0);
    }
    void PrimRaiseExceptionOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 0);
    }
  }];
}

def Torch_PrimUninitializedOp : Torch_Op<"prim.Uninitialized", [
    Pure,
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::Uninitialized : () -> (Any)`";
  let arguments = (ins
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimUninitializedOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 0, 1);
    }
    void PrimUninitializedOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 0, 1);
    }
  }];
  let hasCanonicalizer = 1;
}

def Torch_PrimUncheckedCastOp : Torch_Op<"prim.unchecked_cast", [
    DeclareOpInterfaceMethods<CastOpInterface>,
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::unchecked_cast : (t) -> (t)`";
  let arguments = (ins
    AnyTorchType:$x
  );
  let results = (outs
    AnyTorchType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimUncheckedCastOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimUncheckedCastOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_PrimPrintOp : Torch_Op<"prim.Print", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::Print : (...) -> ()`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands))";
}

def Torch_PrimTolistOp : Torch_Op<"prim.tolist", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::tolist : (...) -> (...)`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
    Variadic<AnyTorchType>:$results
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands)) `->` qualified(type($results))";
}

def Torch_PrimAbsScalarOp : Torch_Op<"prim.abs.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::abs.Scalar : (Scalar) -> (Scalar)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    AnyTorchScalarType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimAbsScalarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimAbsScalarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimsConvertElementTypeOp : Torch_Op<"prims.convert_element_type", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::convert_element_type : (Tensor, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$a,
    Torch_IntType:$dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsConvertElementTypeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimsConvertElementTypeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_PrimsVarOp : Torch_Op<"prims.var", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::var : (Tensor, int[]?, float, int?) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$inp,
    AnyTorchOptionalListOfTorchIntType:$dims,
    Torch_FloatType:$correction,
    AnyTorchOptionalIntType:$output_dtype
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsVarOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void PrimsVarOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

def Torch_PrimsSqrtOp : Torch_Op<"prims.sqrt", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::sqrt : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$self
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsSqrtOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimsSqrtOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
}

def Torch_PrimsCollapseOp : Torch_Op<"prims.collapse", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::collapse : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$a,
    Torch_IntType:$start,
    Torch_IntType:$end
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsCollapseOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void PrimsCollapseOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_PrimsSplitDimOp : Torch_Op<"prims.split_dim", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::split_dim : (Tensor, int, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$a,
    Torch_IntType:$dim,
    Torch_IntType:$outer_length
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsSplitDimOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 3, 1);
    }
    void PrimsSplitDimOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 3, 1);
    }
  }];
}

def Torch_PrimsSqueezeOp : Torch_Op<"prims.squeeze", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::squeeze : (Tensor, int[]) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$a,
    AnyTorchListOfTorchIntType:$dimensions
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsSqueezeOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 2, 1);
    }
    void PrimsSqueezeOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 2, 1);
    }
  }];
}

def Torch_PrimsViewOfOp : Torch_Op<"prims.view_of", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prims::view_of : (Tensor) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult PrimsViewOfOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 1, 1);
    }
    void PrimsViewOfOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 1, 1);
    }
  }];
  let hasFolder = 1;
}

def Torch_QuantizedLinearOp : Torch_Op<"quantized.linear", [
    HasValueSemantics,
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `quantized::linear : (Tensor, __torch__.torch.classes.quantized.LinearPackedParamsBase, float, int) -> (Tensor)`";
  let arguments = (ins
    AnyTorchTensorType:$X,
    Torch_LinearParamsType:$W_prepack,
    Torch_FloatType:$Y_scale_i,
    Torch_IntType:$Y_zero_point_i
  );
  let results = (outs
    AnyTorchTensorType:$Y
  );
  let hasCustomAssemblyFormat = 1;
  let extraClassDefinition = [{
    ParseResult QuantizedLinearOp::parse(OpAsmParser &parser, OperationState &result) {
      return parseDefaultTorchOp(parser, result, 4, 1);
    }
    void QuantizedLinearOp::print(OpAsmPrinter &printer) {
      printDefaultTorchOp(printer, *this, 4, 1);
    }
  }];
}

