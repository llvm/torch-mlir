//===-------------------------------------------------------*- tablegen -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Also available under a BSD-style license. See LICENSE.
//
// Operation summaries and descriptions were systematically derived from public
// API docstrings and are licensed accordingly:
//   https://github.com/pytorch/pytorch/blob/master/LICENSE
//===----------------------------------------------------------------------===//
//
// This file is automatically generated.  Please do not edit.
// Generated via:
//   python -m torch_mlir.dialects.torch.importer.jit_ir.build_tools.torch_ods_gen
//
//===----------------------------------------------------------------------===//

def Torch_PrimLayoutOp : Torch_Op<"prim.layout", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::layout : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let assemblyFormat = "$a attr-dict `:` qualified(type($a)) `->` qualified(type($result))";
}

def Torch_PrimTupleIndexOp : Torch_Op<"prim.TupleIndex", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::TupleIndex : (Any, int) -> (Any)`";
  let arguments = (ins
    AnyTorchType:$tup,
    Torch_IntType:$i
  );
  let results = (outs
    AnyTorchType:$result
  );
  let assemblyFormat = "$tup `,` $i attr-dict `:` qualified(type($tup)) `,` qualified(type($i)) `->` qualified(type($result))";
  let hasCanonicalizer = 1;
}

def Torch_PrimDeviceOp : Torch_Op<"prim.device", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::device : (Tensor) -> (Device)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_DeviceType:$result
  );
  let assemblyFormat = "$a attr-dict `:` qualified(type($a)) `->` qualified(type($result))";
}

def Torch_PrimDtypeOp : Torch_Op<"prim.dtype", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::dtype : (Tensor) -> (int)`";
  let arguments = (ins
    AnyTorchTensorType:$a
  );
  let results = (outs
    Torch_IntType:$result
  );
  let assemblyFormat = "$a attr-dict `:` qualified(type($a)) `->` qualified(type($result))";
  let hasFolder = 1;
}

def Torch_PrimTupleUnpackOp : Torch_Op<"prim.TupleUnpack", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::TupleUnpack : (Any) -> (...)`";
  let arguments = (ins
    AnyTorchType:$tup
  );
  let results = (outs
    Variadic<AnyTorchType>:$results
  );
  let assemblyFormat = "$tup attr-dict `:` qualified(type($tup)) `->` qualified(type($results))";
  let hasCanonicalizer = 1;
}

def Torch_PrimNumToTensorScalarOp : Torch_Op<"prim.NumToTensor.Scalar", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::NumToTensor.Scalar : (Scalar) -> (Tensor)`";
  let arguments = (ins
    AnyTorchScalarType:$a
  );
  let results = (outs
    AnyTorchTensorType:$result
  );
  let assemblyFormat = "$a attr-dict `:` qualified(type($a)) `->` qualified(type($result))";
}

def Torch_PrimMinSelfIntOp : Torch_Op<"prim.min.self_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::min.self_int : (int[]) -> (int)`";
  let arguments = (ins
    TorchIntListType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let assemblyFormat = "$self attr-dict `:` qualified(type($self)) `->` qualified(type($result))";
  let hasFolder = 1;
}

def Torch_PrimMinIntOp : Torch_Op<"prim.min.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::min.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let assemblyFormat = "$a `,` $b attr-dict `:` qualified(type($a)) `,` qualified(type($b)) `->` qualified(type($result))";
}

def Torch_PrimMaxSelfIntOp : Torch_Op<"prim.max.self_int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::max.self_int : (int[]) -> (int)`";
  let arguments = (ins
    TorchIntListType:$self
  );
  let results = (outs
    Torch_IntType:$result
  );
  let assemblyFormat = "$self attr-dict `:` qualified(type($self)) `->` qualified(type($result))";
}

def Torch_PrimMaxIntOp : Torch_Op<"prim.max.int", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::max.int : (int, int) -> (int)`";
  let arguments = (ins
    Torch_IntType:$a,
    Torch_IntType:$b
  );
  let results = (outs
    Torch_IntType:$result
  );
  let assemblyFormat = "$a `,` $b attr-dict `:` qualified(type($a)) `,` qualified(type($b)) `->` qualified(type($result))";
  let hasFolder = 1;
}

def Torch_PrimRaiseExceptionOp : Torch_Op<"prim.RaiseException", [
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::RaiseException : (str, str?) -> ()`";
  let arguments = (ins
    Torch_StringType:$msg,
    TorchOptionalStringType:$cls
  );
  let results = (outs
  );
  let assemblyFormat = "$msg `,` $cls attr-dict `:` qualified(type($msg)) `,` qualified(type($cls))";
}

def Torch_PrimUninitializedOp : Torch_Op<"prim.Uninitialized", [
    NoSideEffect,
    AllowsTypeRefinement,
    HasValueSemantics,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::Uninitialized : () -> (Any)`";
  let arguments = (ins
  );
  let results = (outs
    AnyTorchType:$result
  );
  let assemblyFormat = " attr-dict `:` qualified(type($result))";
  let hasCanonicalizer = 1;
}

def Torch_PrimUncheckedCastOp : Torch_Op<"prim.unchecked_cast", [
    DeclareOpInterfaceMethods<CastOpInterface>,
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::unchecked_cast : (t) -> (t)`";
  let arguments = (ins
    AnyTorchType:$x
  );
  let results = (outs
    AnyTorchType:$result
  );
  let assemblyFormat = "$x attr-dict `:` qualified(type($x)) `->` qualified(type($result))";
  let hasFolder = 1;
}

def Torch_PrimPrintOp : Torch_Op<"prim.Print", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::Print : (...) -> ()`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands))";
}

def Torch_PrimTolistOp : Torch_Op<"prim.tolist", [
    AllowsTypeRefinement,
    ReadOnly
  ]> {
  let summary = "Generated op for `prim::tolist : (...) -> (...)`";
  let arguments = (ins
    Variadic<AnyTorchType>:$operands
  );
  let results = (outs
    Variadic<AnyTorchType>:$results
  );
  let assemblyFormat = "`(` $operands `)` attr-dict `:` qualified(type($operands)) `->` qualified(type($results))";
}

